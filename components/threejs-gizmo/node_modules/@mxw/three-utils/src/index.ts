// Collection of 3D Utility functions
import * as THREE from '@mxw/three';
import { Quaternion, Vector3, wom } from 'maxwhere';

type AngleAxis = {
  axis: {
    x: number;
    y: number;
    z: number;
  };

  angle: number;
};

/**
 * Converts Three.js Quatrenion to MaxWhere quaterion.
 * @param q
 * @returns
 */
function QuatToMw(q: THREE.Quaternion): Quaternion {
  return {
    x: q.x,
    y: q.y,
    z: q.z,
    w: q.w,
  };
}

/**
 * Converts Three.js Vector3 to MaxWhere vector.
 * @param v
 * @returns
 */
function V3ToMw(v: THREE.Vector3): Vector3 {
  return {
    x: v.x,
    y: v.y,
    z: v.z,
  };
}

/**
 * Converts MaxWhere vector to Three.js Vector3
 * @param pos
 * @returns
 */
function V3ToThree(pos: Vector3) {
  return new THREE.Vector3(pos.x, pos.y, pos.z);
}

/**
 * Convert MaxWhere quaternion to Three.js Quaternion
 * @param ori
 * @returns
 */
function QuatToThree(ori: Quaternion) {
  return new THREE.Quaternion(ori.x, ori.y, ori.z, ori.w);
}

/**
 * Rotates a MaxWhere quaternion on an axis by a defined angle
 * @param quaterion initial quaternion
 * @param axis A normalized vector representing the axis
 * @param angle angle in degree
 * @returns
 */
function rotateQuaternionOnAxis(
  quaterion: Quaternion,
  axis: Vector3,
  angle: number,
) {
  let baseOri = QuatToThree(quaterion);
  let rotateOffset = new THREE.Quaternion().setFromAxisAngle(
    V3ToThree(axis),
    THREE.MathUtils.degToRad(angle),
  );

  let newOri = QuatToMw(
    new THREE.Quaternion().multiplyQuaternions(baseOri, rotateOffset),
  );

  return newOri;
}

/**
 * Look at a direction with an object.
 * @param forward forward direction at identity quaternion
 * @param up up direction at identity quaternion
 * @param dir direction vector to rotate to
 * @returns
 */
function lookAtDir(
  forward: THREE.Vector3,
  up: THREE.Vector3,
  dir: THREE.Vector3,
) {
  let rotationMatrix = new THREE.Matrix4().lookAt(
    dir,
    new THREE.Vector3(0, 0, 0),
    up,
  );
  let ori = QuatToMw(
    new THREE.Quaternion()
      .setFromRotationMatrix(rotationMatrix)
      .multiply(
        new THREE.Quaternion().setFromUnitVectors(
          new THREE.Vector3(0, 0, -1),
          forward,
        ),
      ),
  );
  return ori;
}

/**
 * Look at a direction with an object.
 * @param forward forward direction at identity quaternion
 * @param up up direction at identity quaternion
 * @param dir direction vector to rotate to
 * @returns
 */
function lookAt(
  fromPos: THREE.Vector3,
  toPos: THREE.Vector3,
  forward?: THREE.Vector3,
  up?: THREE.Vector3,
) {
  let rotationMatrix = new THREE.Matrix4().lookAt(
    fromPos,
    toPos,
    up || new THREE.Vector3(0, 1, 0),
  );

  let ori = new THREE.Quaternion()
    .setFromRotationMatrix(rotationMatrix)
    .multiply(
      new THREE.Quaternion().setFromUnitVectors(
        new THREE.Vector3(0, 0, -1),
        forward || new THREE.Vector3(0, 0, 1),
      ),
    );

  return ori;
}

function worldToLocal(pos: THREE.Vector3, matrix: THREE.Matrix4) {
  return pos.clone().applyMatrix4(matrix.clone().invert());
}

/**
 * Translates MaxWhere vector on a direction by a defined distance
 * @param position Initial position
 * @param direction direction vector
 * @param distance
 * @returns
 */
function translatePositionOnDirection(
  position: Vector3,
  direction: Vector3,
  distance: number,
) {
  return V3ToMw(
    V3ToThree(direction).multiplyScalar(distance).add(V3ToThree(position)),
  );
}

function V3Flip(pos: Vector3) {
  return new THREE.Vector3(1 / pos.x, 1 / pos.y, 1 / pos.z);
}

/**
 * Converts quaternion to angle and axis
 * @param quat quaternion
 * @returns AngleAxis object
 */
function getAngleAxisFromQuaternion(quat: THREE.Quaternion): AngleAxis {
  let axis: Vector3 = { x: 0, y: 0, z: 0 };
  if (quat.w > 1) quat.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised
  let angle = THREE.MathUtils.radToDeg(2 * Math.acos(quat.w));
  let s = Math.sqrt(1 - quat.w * quat.w); // assuming quaternion normalised then w is less than 1, so term always positive.
  if (s < 0.001) {
    // test to avoid divide by zero, s is always positive due to sqrt
    // if s close to zero then direction of axis not important
    axis.x = quat.x; // if it is important that axis is normalised then replace with x=1; y=z=0;
    axis.y = quat.y;
    axis.z = quat.z;
  } else {
    axis.x = quat.x / s; // normalise axis
    axis.y = quat.y / s;
    axis.z = quat.z / s;
  }
  axis.x = Math.round(axis.x * 100) / 100;
  axis.y = Math.round(axis.y * 100) / 100;
  axis.z = Math.round(axis.z * 100) / 100;

  return { axis: axis, angle: angle };
}

export default {
  QuatToMw,
  V3ToMw,
  V3ToThree,
  QuatToThree,
  translatePositionOnDirection,
  V3Flip,
  rotateQuaternionOnAxis,
  lookAt: lookAt,
  lookAtDir: lookAtDir,
  getAngleAxisFromQuaternion,
  worldToLocal: worldToLocal,
};
