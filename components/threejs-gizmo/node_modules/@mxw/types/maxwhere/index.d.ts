/// <reference types="node" />
/// <reference types="../electron/index"/>

declare module 'maxwhere' {
  export = MaxWhere;
}
declare namespace MaxWhere {
  const wom: Wom;
  const modules: {
    mxwStateProxy: StateProxy;
    mxwAssetProxy: AssetProxy;
  };
  const context: Context;

  interface Context extends NodeJS.EventEmitter {
    addWomListener(
      womEventName: string,
      listenerName: string,
      listener: Function,
      active?: boolean,
    ): void;
    removeWomListener(listenerName: string): void;
    setWomListenerActive(listenerName: string, active: boolean): void;
    addContext(contextName: string, onEnter: Function, onLeave: Function): void;
    removeContext(contextName: string): void;
    changeContext(contextName: string): void;
  }
  interface StateProxy {
    init(opts: { client: object; where: object }): void;
    where: WhereStateProxy;
    client: ClientStateProxy;
  }
  interface AssetProxy {
    getAssetByName(
      name: string,
      handler: (progress: { percent: number }) => void,
    ): Promise<string[]>;
  }
  interface MenuMode {
    BASE: string;
    CROSSHAIR: string;
    PEBBLES: string;
    STORYAUTOPLAY: string;
  }
  interface MenuStates {
    INITIAL: number;
    CROSSHAIR: number;
    PEBBLES: number;
    EMPTY: number;
    HELP: number;
  }
  interface WhereStateProxy extends NodeJS.EventEmitter {
    menucontext: MenuMode;
    menustates: MenuStates;
    story: {
      locations: Function;
      reload: Function;
      resetSteps: (locations: object) => void;
      stop: Function;
      next: (opts: object) => void;
      previous: (opts: object) => void;
    };
    menu: {
      goCrosshairMode: Function;
      transitMode: Function;
      goMode: (mode: number) => void;
    };
  }

  interface ClientStateProxy {
    userid: string;
    whereid: string;
  }

  /**
   * The wom object is the main module of a maxwhere app.
   *
   * It's used to manage app lifecycle, access maxwhere engine resources and features and populate 3d scene. It is subclass of Node class and serves as a root node for every object in the 3d scene.
   * @extends Node
   */
  export type Wom = ProtoExntends<Node, WomExt>;
  interface WomExt {
    /**
     * A Node that is the camera node of the 3D scene.
     */
    camera: Node;
    /**
     * An Object storing the configuration properties of the app. It is either read from a .json file or an object passed to wom.load or wom.start directly.
     */
    appConfig: AppConfig;

    /**
     * An Object storing the configuration properties of the loaded where. It is either read from a .json file or an object passed to wom.load directly. It's a superset of wom.appConfig and passed to wom.start after processing.
     */
    whereConfig: WhereConfig;

    /**
     * A String that is the absolute URL of the where configuration files (if read from a .json, it's automatically assigned to the containing folder).
     */
    whereConfigURL: string;

    /**
     * An Object of Resource groups and corresponding resource folder paths added to wom (keys: String - group name, values: String[] resource locations)
     */
    resourcePaths: {
      [name: string]: string[];
    };

    /**
     * A Boolean indicating that the native window has been loaded successfully. When turns true, 'native ready' event is emitted
     */
    isNativeReady: boolean;

    /**
     * A Boolean indicating that the wom has been set up successfully and ready to use.
     */
    isReady: boolean;

    /**
     * A Boolean indicating that the maxwhere engine is quitting. When turns true, 'quit' event is emitted
     */
    isQuitting: boolean;

    /**
     * Get list of files on a resource group
     *
     * @param resourceKey key of resource group
     * @returns file names
     */
    getResourceFileList(resourceKey: string): string[];

    /**
     * Starts maxwhere engine using provided options. Opens a new native window with an empty scene.
     * @param opts Options for the app, can contain the same properties as wom.appConfig
     * @param callback Called when maxwhere engine is successfully started
     */
    start(opts?: AppConfig, callback?: Function): void;

    load(config?: WhereConfig | string, callback?: Function): void;

    /**
     * Clears the entire 3d scene by removing every child node of wom
     */
    clear(): void;
    /**
     * Reloads the scene by calling wom.load with the current configuration. This means that the scene will be cleared and only objects described in whereConfig will be created again.
     * @param callback Called when the scene is reloaded. This state not necessarily means that object creation is finished (use 'ready' callback for react when every mesh is loaded)
     */
    reload(callback?: Function): void;
    /**
     * Shuts down the maxwhere engine and clears the 3d scene (destroys wom tree). During the run of this function 'before-close' and 'after-close' are emitted
     */
    close(): void;
    /**
     * Creates an element with the provided type and options. The created element becomes a child of wom root node. The created element is not rendered into the 3d scene automatically! For built-in types the created element is an object in wom tree, while for custom types rendering is up to provided render function.
     * @param name Name of the element type to create. Type name can be built-in element or installed component.
     * @param opts Options passed to constructor of element type. For built-in elements consult the documentation of the specific type for complete attribute list. For installed components and functional builders see the user-defined description of the specific type.
     * @param children  An array of child elements to append to the created element.
     * @returns The create Node instance
     */
    create(name: 'node', opts: NodeOptions, children?: Array<Node>): Node;
    create(name: 'mesh', opts: MeshOptions, children?: Array<Node>): Mesh;
    create(name: 'label', opts: LabelOptions, children?: Array<Node>): Label;
    create(name: 'canvas', opts: CanvasOptions, children?: Array<Node>): Canvas;
    create(name: 'light', opts: LightOptions, children?: Array<Node>): Light;
    create(
      name: 'overlay',
      opts: OverlayOptions,
      children?: Array<Node>,
    ): Overlay;
    create(
      name: 'webview',
      opts: WebviewOptions,
      children?: Array<Node>,
    ): Webview;
    create(
      name: 'webtable',
      opts: WebtableOptions,
      children?: Array<Node>,
    ): Webtable;
    create(
      name: 'billboard',
      opts: BillBoardOptions,
      children?: Array<Node>,
    ): Billboard;
    create(
      name: 'manualvisual',
      opts: ManualVisualOptions,
      children?: Array<Node>,
    ): ManualVisual;

    create(
      name: 'instancedmesh',
      opts: InstancedMeshOptions,
      children?: Array<Node>,
    ): InstancedMesh;

    /**
     * Installs the specified component as available wom element type. After installing components they can be created directly with wom.create.
     * @param path Path of component descriptor file. Can point to .js<x> file directly or a .json file which is a description of the component. If points to a folder function will look for component.json file in it.
     * @param name The name of the component to install
     * @param type Type of component. If it's 'internal', every Where can use installed component. Otherwise wom.clear will uninstall it. Default is 'where' (non-internal)
     */
    installComponent(path: string, name: string, type?: string): void;

    /**
     * Appends the specified configuration object to wom's current appConfig (overwriting common properties) and applies it.
     * @param config Application configuration to set (For property list see wom.appConfig)
     * @param done Called when the configuration is set successfully.
     */
    setAppConfig(config: AppConfig, done?: Function): void;

    /**
     * Resets appConfig to its default state appended with the specified configuration and applies it.
     * @param config  Application configuration to set (For property list see wom.appConfig)
     * @param done Called when the configuration is set successfully.
     */
    resetAppConfig(config: AppConfig, done?: Function): void;

    /**
     * Appends the specified configuration object to wom's current whereConfig (overwriting common properties) and applies it.
     * @param config Where configuration to set (For property list see wom.whereConfig)
     * @param done  Called when the configuration is set successfully.
     */
    setWhereConfig(config: WhereConfig, done?: Function): void;

    /**
     * Resets whereConfig to its default state appended with the specified configuration and applies it.
     * @param config Where configuration to set (For property list see wom.whereConfig)
     * @param done Called when the configuration is set successfully.
     */
    resetWhereConfig(config: WhereConfig, done?: Function): void;
    /**
     * Adds folder paths to collection of resource containing paths. It creates and initializes a new resource group and append paths to that group. Any resource used by wom elements should be available in one of resource folders at the time of element creation (e.g. mesh and physical obj files)
     * @param paths  Resource folder paths to add. They can be relative path or absolute path. If given with a single String it will be converted to String[].
     * @param base Base folder for relative paths if paths are defined relatively. Not used otherwise.
     * @param done Called after the resource group is initialized and populated successfully in maxwhere engine.
     */
    addResources(
      paths: string | Array<string>,
      base?: string,
      done?: (id: string) => void,
    ): string;
    /**
     * Removes resource group and associated folder paths in maxwhere engine.
     * @param groupid  ID of resource group to remove. If no group ID is specified every resource group is removed!
     * @param done Called after the resource group is destroyed and every associated folder path is removed
     */
    removeResources(groupid?: string, done?: Function): void;

    /**
     * @returns every material name which is available to use by wom elements. Returns Object - Key-Value Map of available material names. Keys are resource group names and values are material names belong to the group
     */
    getAvailableMaterialNames(): { [key: string]: Array<string> };

    /**
     * Enables or disables native window's fullscreen mode.
     * @param enable Enable or disable fullscreen mode.
     */
    setFullScreen(enable: boolean): void;

    /**
     * @returns Boolean - Is native window in fullscreen mode currently.
     */
    isFullScreen(): boolean;

    /**
     * Moves the native window to the center of specified display and resizes it to the size of the display.
     * @param display https://www.electronjs.org/docs/api/structures/display
     */
    setDisplay(display: any): void;
    /**
     *
     */
    /**
     * Gets the current display of the native window. Matching display is calculated from native window's position and size.
     * @returns https://www.electronjs.org/docs/api/structures/display
     */
    getDisplay(): void;

    /**
     * @returns Object {r, g, b, a} - The current color of scene's ambient light.
     */
    getAmbient(): Color;

    /**
     * Sets the color of scene's ambient light
     * @param color The color of scene's ambient light. {r, g, b, a} Default {r: 1, g: 1, b: 1, a: 1}
     */
    setAmbient(color?: Color): void;

    /**
     * Sets fog properties of the scene.
     * @param mode
     * @param color
     * @param expDensity
     * @param linearStart
     * @param linearEnd
     */
    setFog(
      mode?: number,
      color?: Color,
      expDensity?: number,
      linearStart?: number,
      linearEnd?: number,
    ): void;
    /**
     * @returns Object - The current fog properties of the scene. Containing the following attributes:
     */
    getFog(): {
      mode?: number;
      color?: Color;
      expDensity?: number;
      linearStart?: number;
      linearEnd?: number;
    };

    /**
     * Sets the background color of 3d viewport.
     * @param color The background color of native window to set. {r, g, b, a} Default {r: 1, g: 1, b: 1, a: 1}
     */
    setBackground(color?: Color): void;

    /**
     * @returns Object {r, g, b, a} - The current background color of 3d viewport.
     */
    getBackground(): Color;

    /**
     * Sets the skybox of the scene with the specified options.
     * @param props
     */
    setSkyBox(props: SkyBoxOptions): void;

    /**
     * @returns Object - The current skybox options of the scene.
     */
    getSkyBox(): SkyBoxOptions;

    /**
     * @returns  - The vertical angle of wom camera's Field of View in degrees.
     */
    getCameraFov(): number;
    /**
     * Set vertical field of view angle
     * @param fovy New field of view angle in degree
     */
    setCameraFov(fovy: number): void;

    /**
     * @returns Object - the movement boundaries of 3d scene's camera
     */
    getCameraLimits(): Limits;

    /**
     * Sets the movement boundaries of 3d scene's camera
     * @param limits  Limit of movement
     */
    setCameraLimits(limits: Limits): void;

    /**
     * @returns Object - The clipping distances of 3d scene's camera. Objects behind far clip distance or before near clip distance are not rendered
     */
    getCameraClipdistances(): { near: number; far: number };

    /**
     * Set clipping distances of 3d scene's camera. Objects behind far clip distance or before near clip distance are not rendered
     * @param near  Near clip distance of camera.
     * @param far  Far clip distance of camera.
     */
    setCameraClipdistances(near: number, far: number): void;

    /**
     * @returns Physical limits for 3d objects of the scene. Effects object with attached physical hitshape only
     */
    getPhysicalLimits(): PhysicalLimits;

    /**
     * Set phyiscal limits for 3d objects of the scene. Effects object with attached physical hitshape only
     * @param limits
     */
    setPhysicalLimits(limits: PhysicalLimits): void;

    /**
     * Enables or disables spatial control in maxwhere. Mouse movement behavior and visiblity of 2D mouse cursor and 3D crosshair (if enabled) changes according to the spatial control state. Camera is not manipulated in 2D cursor mode (set false) but mouse events are sent to navigation controller in 3D crosshair mode (set true - Coginav rotates the camera).
     * @param enable Enable or disable spatial control in maxwhere.
     */
    setSpatialControl(enable: boolean): void;

    /**
     * Gets the current state of spatial control. 2D cursor mode returns false while 3D crosshair mode returns true
     */
    isSpatialControlEnabled(): boolean;

    /**
     * Holds the spatial control of 3d scene. Disable/enable every input event propagation in the maxwhere engine.
     * @param hold Enable or disable spatial control
     */
    holdSpatialControl(hold: boolean): void;

    /**
     * Sets the mouse cursor style in maxwhere. Final look depends on OS iconset.
     * @param type Cursor type. Possible values: default, context-menu, text, wait, crosshair, progress, nwse-resize, nw-resize, se-resize, nesw-resize, sw-resize, ne-resize, ew-resize, w-resize, e-resize, na-resize, s-resize, n-resize, move, all-scroll, pointer, custom
     * @param data Image data of custom type cursor provided as RGB bitmap. Default null
     * @param w Width of custom type cursor image. Default 0
     * @param h  Height of custom type cursor image. Default 0
     * @param x Horizontal position of custom type cursor in screen coordinates. Default 0
     * @param y Vertical position of custom type cursor in screen coordinates. Default 0
     * @param scale Scale of cursor. Default 1
     */
    setCursor(
      type: string,
      data?: Buffer,
      w?: number,
      h?: number,
      x?: number,
      y?: number,
      scale?: number,
    ): void;

    /**
     * Enables or disables the default native crosshair of maxwhere. If disabled, 3D crosshair mode will show nothing on the screen center but still will activate mouse movement capture and manipulate camera. Useful for costumizing crosshair's look
     * @param ebable Enable or disable native crosshair.
     */
    setCrosshairEnabled(ebable: boolean): void;

    /**
     * @returns Boolean - Is default native crosshair enabled.
     */
    isCrosshairEnabled(): boolean;

    /**
     * Shows the native window.
     */
    showWindow(): void;

    /**
     * Hides the native window.
     */
    hideWindow(): void;

    /**
     * @returns Boolean - whether the native window is visible
     */
    isWindowVisible(): boolean;

    /**
     * @returns Boolean - size of the native window
     */
    getWindowSize(): { width: number; height: number };

    /**
     * Returns Object - The current size of native window. Window size is in raw pixels, which is multiplied with pixel scale factor
     * @param width
     * @param height
     */
    setWindowSize(width: number, height: number): void;

    /**
     * @returns the native window's pixel scale factor. Factor is automatically adjusted when the window is moved or changed display. See 'dpi-changed' event
     */
    getWindowPixelScaleFactor(): number;

    /**
     * Returns String - the current title of the native window
     */
    getWindowTitle(): string;

    /**
     * Sets the title of native window
     * @param title
     */
    setWindowTitle(title: string): void;

    /**
     * Maximizes the native window
     */
    maximize(): void;

    /**
     * Restore the native window if it's maximized.
     */
    unmaximize(): void;

    /**
     * Enables or disables mouse input grab on native window. When mouse is grabbed by the window user is not able to leave the window's working area with the cursor.
     * @param enable Enable or disable mouse input grab on native window.
     */
    setInputGrab(enable: boolean): void;

    /**
     * @returns Boolean - Is mouse input grabbed by native window.
     */
    isInputGrabbed(): void;

    /**
     * Sets whether the 3d scene should be rendered or not. Overlays are keep rendered even when 3d scene is not
     * @param render Enable or disable 3d rendering
     */
    setWorldRendering(render: boolean): void;

    /**
     * @returns Boolean - Whether the 3d scene is rendering. Overlays are keep rendered even when 3d scene is not
     */
    isWorldRendering(): void;

    /**
     * Sets the current session of wom. Sessions are used for managing browser local data
     * @param sessionName Name of session to use.
     */
    setCurrentSession(sessionName: string): void;

    /**
     * @returns Electron.Session - The currently used session of wom.
     */
    getCurrentSession(): Electron.Session;

    setMouseSensitivity(sensitivity: number): void;

    getMouseSensitivity(): number;

    setScrollSensitivity(sensitivity: number): void;

    getScrollSensitivity(): number;

    setTouchSensitivity(sensitivity: number): void;

    getTouchSensitivity(): void;

    /**
     * Registers an event listener. Handler function will be called every time when the specified event is fired in maxwhere engine or wom.
     * @param eventName Event type descriptor
     * @param handler  Handler function taking event as argument where event is an Object containing different properties according to the event type.
     */
    on(eventName: WomCoreEventDescriptor, handler: Function): this;
    on(
      eventName: NodeMouseEventDesciptor | 'strafeclick' | 'input-mouse',
      handler: (event: NodeMouseEventObject) => void,
    ): this;
    on(
      eventName: NodeMouseWheelEventDescriptor,
      handler: (event: NodeMouseWheelEventObject) => void,
    ): this;

    /**
     * Registers an event listener. Handler function will be called for the first time when the specified event is fired in maxwhere engine or wom. After the first event the listener will be unregistered.
     * @param eventName Event type descriptor
     * @param handler  Handler function taking event as argument where event is an Object containing different properties according to the event type.
     */
    once(
      eventName: NodeMouseEventDesciptor | 'strafeclick' | 'input-mouse',
      handler: (event: NodeMouseEventObject) => void,
    ): this;
    once(
      eventName: NodeMouseWheelEventDescriptor,
      handler: (event: NodeMouseWheelEventObject) => void,
    ): this;

    once(eventName: WomCoreEventDescriptor, handler: Function): this;

    on(
      eventName: WomInsertedEventDescriptor,
      handler: WomInsertedEventHandler,
    ): this;

    once(
      eventName: WomInsertedEventDescriptor,
      handler: WomInsertedEventHandler,
    ): this;

    on(
      eventName: WomLoadingStateChangedEventDescriptor,
      handler: (event: WomLoadingStateChangedEventObject) => void,
    ): this;

    once(
      eventName: WomLoadingStateChangedEventDescriptor,
      handler: (event: WomLoadingStateChangedEventObject) => void,
    ): this;

    on(
      eventName: WomUnLoadingStateChangedEventDescriptor,
      handler: (event: WomUnLoadingStateChangedEventObject) => void,
    ): this;

    once(
      eventName: WomUnLoadingStateChangedEventDescriptor,
      handler: (event: WomUnLoadingStateChangedEventObject) => void,
    ): this;

    on(
      eventName: WomResizeEventDescriptor,
      handler: (event: WomResizeEventObject) => void,
    ): this;

    once(
      eventName: WomResizeEventDescriptor,
      handler: (event: WomResizeEventObject) => void,
    ): this;

    on(
      eventName: WomDPIChangeEventDescriptor,
      handler: (event: WomDPIChangeChangedEventObject) => void,
    ): this;

    once(
      eventName: WomDPIChangeEventDescriptor,
      handler: (event: WomDPIChangeChangedEventObject) => void,
    ): this;

    on(
      eventName: WomKeyboardEventDescriptor,
      handler: (event: WomKeyboardEventObject) => void,
    ): this;

    once(
      eventName: WomKeyboardEventDescriptor,
      handler: (event: WomKeyboardEventObject) => void,
    ): this;

    on(
      eventName: WomInputTextEventDescriptor,
      handler: (event: WomInputTextEventObject) => void,
    ): this;

    once(
      eventName: WomInputTextEventDescriptor,
      handler: (event: WomInputTextEventObject) => void,
    ): this;

    on(
      eventName: WomCommonEventDescriptor,
      handler: (event: WomCommonEventObject) => void,
    ): this;

    once(
      eventName: WomCommonEventDescriptor,
      handler: (event: WomCommonEventObject) => void,
    ): this;

    /**
     * Unregisters an event listener for the specified event. Handler function should be identical to the one which used to register the listener. That is it's not enough to have the same function body they should be the same javascript object. Consequently equivalent lambdas are not accepted
     * @param eventName Event type descriptor
     * @param handler  Handler function taking event as argument where event is an Object containing different properties according to the event type.
     */
    removeListener(eventName: WomEventDescriptor, handler: Function): void;
  }

  interface PhysicalLimits {
    x: {
      min: number;
      max: number;
    };
    y: {
      min: number;
      max: number;
    };
    z: {
      min: number;
      max: number;
    };
  }

  interface Limits {
    min: Vector3;
    max: Vector3;
  }

  interface SkyBoxOptions {
    /**
     * Is skybox enabled.
     */
    enable: boolean;
    /**
     * Material name of skybox.
     */
    material: string;
    /**
     * Distance of skybox
     */
    ditance: number;
  }

  /**
   * Visual object in 3d scene. Appearance is described with mesh file.
   * @extends Node
   */
  export interface Mesh extends Node {
    /**
     * A String that specifies the Ogre mesh file used by this Mesh. It's file path relative to available resource folders.
     */
    url: string;
    /**
     * A Boolean - Additionally to Node.created property it also shows that the Mesh is successfully loaded into 3d scene.
     */
    created: boolean;
    /**
     * A Function - Additionally to Node.done property it is getting called only when the Mesh is successfully loaded into 3d scene.
     */
    done: Function;

    /**
     *
     * @param url Path to mesh file relative to any resource folder.
     */
    setUrl(url: string): this;

    /**
     * Sets the material on the specified subvisual of the Mesh. Mesh files can contain multiple sub-units for visualize 3d object. They are the 'subvisual's. They have different material applied.
     * @param material The name of material to apply.
     * @param subvisual  The index of subvisual of Mesh. If no subvisual is given the material will be applied on every subvisual.
     */
    setMaterial(material: string, subvisual?: number): this;

    /**
     * @returns the array of subvisuals of this Mesh
     */
    subvisuals(): Array<Subvisual>;

    /**
     * @returns the specified subvisual of this Mesh
     * @param index Returns Object -  Index of subvisual of Mesh to get.
     */
    subvisual(index: number): Subvisual;

    /**
     *
     * @param subvisual Subvisual object to extract the material from.
     * @returns Extracted Material object of the specified subvisual Object. See Material documentation for object details.
     */
    material(subvisual: Subvisual): Material;

    /**
     * @returns String[] containing the available animations for the mesh file of Mesh. Animations can be controlled by passing the name to Mesh.animator. Ogre mesh files can contain vertex or skeleton animations which can be accessed here
     */
    animatorNames(): Array<string>;

    /**
     * Extracts the specified mesh animation object from Mesh
     * @param name Name of the mesh animation to extract
     */
    animator(name: string): Animator;
    /**
     * Saves this Mesh into a file.  Any modification made to Mesh will be saved. Overwrites file if exists!
     * @param path The path to file.
     */
    save(path: string): this;

    /**
     * Shows the mesh in 3d scene.
     */
    show(): this;
    /**
     * Hides the mesh in 3d scene.
     */
    hide(): this;
  }

  /**
   *
   * Instanced visual object in 3d scene. Appearance is described with mesh file.
   *
   * @extends Mesh
   */
  export interface InstancedMesh extends Mesh {}

  /**
   * 3D label to display text.
   * @extends Node
   */
  export interface Label extends Node {
    /**
     * Gets text displayed
     */
    getCaption(): string;
    /**
     * Sets displayed text
     * @param caption text displayed
     */
    setCaption(caption: string): Label;
    /**
     * Get position offset compared to it's Node
     */
    getOffset(): Vector3;
    /**
     * Set position offset compared to it's Node
     * @param offset position
     */
    setOffset(offset: Vector3): Label;
    /**
     * Get display text size
     */
    getCharHeight(): number;
    /**
     * Set display text size
     * @param height size
     */
    setCharHeight(height: number): Label;
    /**
     * Sets color of display text
     * @param color RGBA code of color
     */
    setColor(color: Color): void;
    /**
     * Gets color of display text
     */
    getColor(): Color;
    enableBackGround(enable: boolean): void;
    setBackgroundColor(color: Color): void;
    getBackgroundColor(): {
      enable: boolean;
      color: Color;
    };
    enableAutoRotating(enable: boolean): void;
    isAutoRotating(): boolean;
  }

  export type LabelOptions = ProtoExntends<NodeOptions, LabelOptionsExt>;
  interface LabelOptionsExt {
    caption?: string;
    ontop?: boolean;
    autorotate?: boolean;
    offset?: Vector3;
    color?: Color;
    background?: {
      enable: boolean;
      color: Color;
    };
    charheight?: number;

    done?: (node: Label) => void;
  }
  interface Animator {
    /**
     *  Starts mesh animation playback from the current time position
     */
    start(): void;
    /**
     * Pauses mesh animation playback
     */
    pause(): void;
    /**
     * Stops mesh animation playback and resets time position.
     */
    stop(): void;
    /**
     * @returns the name of mesh animation as String.
     */
    getName(): string;
    /**
     * @returns the type of mesh animation based on Ogre Animation categories. Possible values are morph, pose, bone.
     */
    getType(): 'morph' | 'pose' | 'bone';
    /**
     * @returns the length of mesh animation in seconds as Number.
     */
    getLength(): number;
    /**
     * @returns the current time position of mesh animation in seconds as Number.
     */
    getTimePos(): number;
    /**
     * @returns whether the mesh animation repeates as Boolean.
     */
    getLoop(): boolean;
    /**
     * @returns the weight of each Poses or Bones in mesh animation as Number if any.
     */
    getWeight(): number;
    /**
     * @returns whether the mesh animation is enabled. An animation is enabled if it's running (even if paused)
     */
    getEnabled(): boolean;
    /**
     * Pass length Number [seconds]. Sets the length of mesh animation.
     * @param length
     */
    setLength(length: number): void;
    /**
     * Pass timepos Number [seconds]. Sets the time position of mesh animation.
     */
    setTimePos(timepos: number): void;
    /**
     * Pass loop Boolean. Sets whether the mesh animation should loop.
     * @param loop
     */
    setLoop(loop: boolean): void;
    /**
     *
     * @param weight Pass weight Number. Sets the weight of mesh animation.
     */
    setWeight(weight: number): void;
  }
  interface Subvisual {
    material: MaterialNode;
    index: number;
  }
  export interface MaterialNode {
    /**
     * @returns String - The name of Material
     */
    GetName(): string;
    GetShaderParamValue(shadername: string): string | number;
  }

  export type ManualVisualOptions = ProtoExntends<
    NodeOptions,
    ManualVisualOptionsExt
  >;
  interface ManualVisualOptionsExt {
    sections?: Section[];
    dynamic?: boolean;
    done?: (node: ManualVisual) => void;
  }

  export interface Section {
    material_name: string;
    renderop:
      | 'pointlist'
      | 'linelist'
      | 'linestrip'
      | 'trianglelist'
      | 'trianglestrip'
      | 'trianglefan';
    geometry: (PositionGeometry | ColorGeometry)[];
  }

  export interface PositionGeometry {
    type: 'position';
    arg: Vector3;
  }
  export interface ColorGeometry {
    type: 'color';
    arg: Color;
  }

  /**
   * Dynamic mesh
   * @extends Node
   */
  export interface ManualVisual extends Node {
    addSection(section: Section): void;
    updateSection(
      index: number,
      geometryArray: (PositionGeometry | ColorGeometry)[],
    ): boolean;
    clearSections(): void;
    numSections(): number;
    setMaterial(index: number, material: Material): void;
    getMaterialName(index: number): string;
    getDynamic(): boolean;
    setDynamic(dynamic: boolean): void;
    setVisible(visible: boolean): boolean;
  }

  export type ShaderTypeNumber =
    | 'SurfacecolorbiasR'
    | 'SurfacecolorbiasG'
    | 'SurfacecolorbiasB'
    | 'SpecularcolorbiasR'
    | 'SpecularcolorbiasG'
    | 'SpecularcolorbiasB'
    | 'SurfacereflectivityA'
    | 'SurfacereflectivityD'
    | 'Specularmultiplier'
    | 'ReflectionPower'
    | 'ReflectionBlurBias'
    | 'RoughnessBias'
    | 'MetallicBias'
    | 'AlphaBias'
    | 'LightBias'
    | 'AoBias'
    | 'Uvchangerlight'
    | 'Uvchangerao'
    | 'TileCount'
    | 'TextureoffsetX'
    | 'TextureoffsetY'
    | 'TileCountNormal'
    | 'TextureoffsetNormalX'
    | 'TextureoffsetNormalY'
    | 'TileCountRoughness'
    | 'TextureoffsetRoughnessX'
    | 'TextureoffsetRoughnessY'
    | 'TileCountMetallic'
    | 'TextureoffsetMetallicX'
    | 'TextureoffsetMetallicY';
  export type ShaderTypeString =
    | 'Diffusemap'
    | 'Normalmap'
    | 'Roughnessmap'
    | 'Metallicmap'
    | 'Reflectionmap'
    | 'Lightmap'
    | 'Ambientocclusionmap';

  /**
   * The Material class is used to gain access to the materials of a Mesh.
   *
   * Materials of standard maxwhere meshes are using a special PBS (physically based shader) shader. Shader properties can be adjusted through Material interface. Other kind of materials are accepted as well in the 3d scene and common properties can be adjusted here.
   */
  export interface Material {
    /**
     * @returns String[] containing the names of the controllable shader PBS parameters.
     * For the standard maxwhere shader the following paramters are returned: [ 'SurfacecolorbiasR', 'SurfacecolorbiasG', 'SurfacecolorbiasB', 'SpecularcolorbiasR', 'SpecularcolorbiasG', 'SpecularcolorbiasB', 'SurfacereflectivityA', 'SurfacereflectivityD', 'Specularmultiplier', 'ReflectionPower', 'ReflectionBlurBias', 'RoughnessBias', 'MetallicBias', 'AlphaBias', 'LightBias', 'AoBias', 'Uvchangerlight', 'Uvchangerao', 'TileCount', 'TextureoffsetX', 'TextureoffsetY', 'TileCountNormal', 'TextureoffsetNormalX', 'TextureoffsetNormalY', 'TileCountRoughness', 'TextureoffsetRoughnessX', 'TextureoffsetRoughnessY', 'TileCountMetallic', 'TextureoffsetMetallicX', 'TextureoffsetMetallicY', 'Diffusemap', 'Normalmap', 'Roughnessmap', 'Metallicmap', 'Reflectionmap', 'Lightmap', 'Ambientocclusionmap' ]
     */
    shaderNames(): string[];
    /**
     * Sets the value of the specified PBS shader parameter
     * @param param String | Number The name or index of shader parameter to adjust
     * @param value String | Number Shader parameter value to set. Choose type accepted by the specified shader parameter
     */
    setShader(param: ShaderTypeNumber | number, value: number): this;
    setShader(param: ShaderTypeString | number, value: string): this;
    /**
     * @returns Object {min: Number, max: Number} describing the minimum and maximum value of the specified shader parameter. Doesn't apply on String type parameters
     * @param param String | Number The name or index of shader parameter to query.
     */
    shaderRange(param: ShaderTypeNumber | number): {
      min: number;
      max: number;
    };
    /**
     * @returns Number which is the current value of the specified shader parameter. Doesn't apply on String type parameters
     * @param param String | Number The name or index of shader parameter to query.
     */
    shaderValue(param: ShaderTypeNumber | number): number;
    /**
     * Saves the Material into file.
     * path Path of file to save into
     */
    save(path: string): this;
    /**
     * Clones this Material
     * @param name String (optional) - Name of the cloned Material to set.
     * @returns Material - New Material with identical properties as original one.
     */
    clone(name?: string): Material;
    /**
     * @returns Object {r, g, b, a} - The diffuse color of Material
     */
    getDiffuse(): Color;
    /**
     * @returns Object {r, g, b, a} - The specular color of Material
     */
    getSpecular(): Color;
    /**
     * @returns Object {r, g, b, a} - The ambient color of Material
     */
    getAmbient(): Color;
    /**
     * @returns Object {r, g, b, a} - The emissive color of Material
     */
    getEmissive(): Color;
    /**
     * @returns Number - The shininess of Material. Shininess affects specular highlights
     */
    getShininess(): number;
    /**
     * @returns Object {write: Boolean, check: Boolean} describing the depth features of Material.
     * Depth feature defines whether the material renders with depth-buffer checking or writing. If write is off material will always be rendered behind everything else. If check is off material will always be rendered on top of everything else.
     */
    getDepthFeatures(): { write: boolean; check: boolean };
    /**
     * @returns Boolean indicating whether Material is transparent.
     */
    isTransparentBlend(): boolean;
    /**
     * @returns Boolean indicating whether Material receives shadows.
     */
    isReceiveShadow(): boolean;
    /**
     * @returns Boolean indicating whether lighting is allowed on Material.
     */
    isLightingAllowed(): boolean;
    /**
     * @returns Number - culling mode of Material. 0 - culling is off 1 - clockwise culling 2 - anticlockwise culling
     */
    getCullingMode(): number;
    /**
     * @returns String - The name of Material
     */
    getName(): string;
    /**
     * Sets the diffuse color of Material
     * @param color Object - Color to set. {r, g, b, a}
     */
    setDiffuse(color: Color): this;
    /**
     * Sets the specular color of Material
     * @param color Object - Color to set. {r, g, b, a}
     */
    setSpecular(color: Color): this;
    /**
     * Sets the ambient color of Material
     * @param color Object - Color to set. {r, g, b, a}
     */
    setAmbient(color: Color): this;
    /**
     * Sets the emissive color of Material
     * @param color Object - Color to set. {r, g, b, a}
     */
    setEmissive(color: Color): this;
    /**
     * Sets the shininess of Material Shininess affects specular highlights
     * @param value Number Shininess to set (non-negative)
     */
    setShininess(value: number): this;
    /**
     * Sets the depth features of Material.
     * @param opt Object - Depth feature to set {write: Boolean, check: Boolean}
     * Depth feature defines whether the material renders with depth-buffer checking or writing. If write is off material will always be rendered behind everything else. If check is off material will always be rendered on top of everything else.
     */
    setDepthFeatures(opt: { write: boolean; check: boolean }): this;
    /**
     * Sets the transparency of Material
     * @param transp Boolean Transparency to set
     */
    setTransparentBlend(transp: boolean): this;
    /**
     * Sets whether the Material receives shadows.
     * @param rec Boolean Enable shadow reception
     */
    setReceiveShadow(rec: boolean): this;
    /**
     * Sets whether lighting is allowed on Material
     * @param allow Boolean Enable lighting
     */
    setLightingAllowed(allow: boolean): this;
    /**
     * Sets culling mode of Material
     * @param mode Number - Culling mode to set. 0 - culling is off 1 - clockwise culling 2 - anticlockwise culling
     */
    setCullingMode(mode: number): this;
  }

  interface WhereConfig extends AppConfig {
    /**
     * Resource folder paths of the where (absolute path or relative to .json containing folder). Default is empty
     */
    local: string[];
    /**
     * Environmental configuration
     */
    environment: {
      /**
       * Viewport background color. Default {r: 0.4, g: 0.4, b: 0.4, a: 1}
       */
      background: Color;
      /**
       *  Scene ambient light color. Default {r: 0.3, g: 0.3, b: 0.3, a: 1}
       */
      ambient: Color;
      /**
       * Fog properties
       */
      fog: {
        /**
         * Fog density mode. Possible values describing the fog density increase: 0(default): fog disabled, 1: Exponential, 2: Squared exponential, 3: Linear.
         */
        mode: 0 | 1 | 2 | 3;
        /**
         * Fog color. Default {r: 1, g: 1, b: 1, a: 1}
         */
        color: Color;
        /**
         *  Fog density in mode 1, 2. Value range is [0-1]. Default 0.001
         */
        expDensity: number;
        /**
         * Fog start distance in mode 3. Default 0.0
         */
        linearStart: number;
        /**
         * Fog full density distance in mode 3. Default 1.0
         */
        linearEnd: number;
      };
      /**
       * Skybox of the scene
       */
      skybox: SkyBoxOptions;
      /**
       * Camera of the scene
       */
    };

    camera: {
      /**
       *  Camera position in world coordinates. Default {x: 0, y: 0, z: 0}
       */
      position: Vector3;
      /**
       * Camera orientation in world frame. Default {w: 1, x: 0, y: 0, z: 0}.
       */
      orientation: Quaternion | AngleAxis;
      /**
       * Movement boundaries of camera. If distance between min and max is zero, no limits are set.
       */
      limits: {
        /**
         * Left-bottom-far corner of bounding box. Default {x: 0, y: 0, z: 0}
         */
        min: Vector3;
        /**
         *  Right-top-near corner of bounding box. Default {x: 0, y: 0, z: 0}
         */
        max: Vector3;
      };
      /**
       * Near clip distance of camera. Default 1.0
       */
      nearClip: number;
      /**
       * Far clip distance of camera. Default 50000.0
       */
      farClip: number;
      /**
       * Vertical field of view angle in degrees. Default 45.0
       */
      fovY: number;
    };
    /**
     * hysical limits for 3D objects of the scene. Every value adds one physical boundary separately directed to scene origin. Default is empty. Effects object with attached physical hitshape only
     */
    physicalLimits: PhysicalLimits;
    /**
     * Key-Value Map of components to install. Installed components can be used in initial scene description in main Default is empty
     */
    components: { [key: string]: string };
    /**
     * Script describing initial scene to load. js or jsx files are accepted. Content of script will be required and passed to wom.render
     */
    main: string;
  }

  interface AppConfig {
    /**
     * Window title. Default MaxWhere
     */
    title: string;
    /**
     * Window width in pixels. Default 1280 Not applied if less than minWidth
     */
    width: number;
    /**
     * Window height in pixels. Default 720 Not applied if less than minHeight
     */
    height: number;
    /**
     * Is window visible. Default true
     */
    show: boolean;
    /**
     * Displaying mode of window. Possible values: manual(default), maximized, fullscreen. For non-manual display modes width and height are calculated automatically!
     */
    displayMode: 'manual' | 'maximized' | 'fullscreen';
    /**
     * Window's position in the frame of displays. Default is the center of the primary display.
     */
    displayPosition: Vector2;
    /**
     * Pixel scale factor of the window. Default is the scale factor of primary display
     */
    displayDPI: number;
    /**
     *  Enable high-DPI resolution display. Default true If disabled, displayDPI is initialized to 1.0
     */
    highDPI: boolean;
    /**
     * Scale of 3d scene (world) resolution according to window (overlay) full resolution. Default is 1
     */
    worldResolutionScale: number;
    /**
     * The 3D navigation mode. Possible values: 'coginav-lite' (default), coginav
     */
    navigation: 'coginav-lite' | 'coginav';
    /**
     * Is 3D navigation automatically switched for right click. Default true Should be false for full control over navigation states
     */
    navigationAutoSwitch: boolean;
    /**
     *  Is crosshair enabled in 3D navigation mode. Default true
     */
    crosshair: boolean;
    /**
     * Minimum window width in pixels. Default 800
     */
    minWidth: number;
    /**
     * Minimum window height in pixels. Default 600
     */
    minHeight: number;
    /**
     * Path to folder where the log file should be generated. Default is %appdata% (C:\Users\<username>\AppData\Roaming) on Windows and /Users/<username>/Library/Preferences on MacOS
     */
    logFolder: string;
    /**
     * Splash screen options. Splash screen is displayed during the startup if defined. Default is undefined. Splash is displayed from start until the first appearance of the native window. If the window is visible it's 'native ready', otherwise it's the first call of wom.showWindow
     */
    splash: { url: string; width: number; height: number };
    /**
     * Spatial anti-aliasing mode of 3d scene. Possible values are OFF (default), FXAA and MSAA
     */
    AAType: 'FXAA' | 'MSAA';
    /**
     * MSAA multisampling option. Possible values are 2, 4, 8 (default)
     */
    AAHint: 2 | 4 | 8;
  }

  interface Vector2 {
    x: number;
    y: number;
  }

  interface EventTypeDescriptor {
    type: string;
    subject?: string;
    object?: Node;
  }
  type WomCommonEventName =
    | 'node-create'
    | 'node-delete'
    | 'node-position'
    | 'node-orientation'
    | 'node-pose'
    | 'node-scale'
    | 'node-parent'
    | 'node-visible'
    | 'light-create'
    | 'light-delete'
    | 'light-type'
    | 'light-diffuse'
    | 'light-specular'
    | 'light-attenuation'
    | 'light-direction'
    | 'light-spotrange'
    | 'light-visible'
    | 'visual-create'
    | 'visual-delete'
    | 'visual-filename'
    | 'visual-material'
    | 'visual-visible'
    | 'visual-save'
    | 'manualvisual-create'
    | 'manualvisual-delete'
    | 'manualvisual-clear'
    | 'manualvisual-updatedirty'
    | 'manualvisual-material'
    | 'manualvisual-dynamic'
    | 'manualvisual-visible'
    | 'material-create'
    | 'material-clone'
    | 'material-delete'
    | 'material-diffuse'
    | 'material-ambient'
    | 'material-specular'
    | 'material-emissive'
    | 'material-shininess'
    | 'material-depthcheck'
    | 'material-depthwrite'
    | 'material-transparent'
    | 'material-recieveshadow'
    | 'material-lighting'
    | 'material-culling'
    | 'material-shaderparamset'
    | 'material-save'
    | 'meshanimation-create'
    | 'meshanimation-update'
    | 'meshanimation-play'
    | 'meshanimation-pause'
    | 'meshanimation-stop'
    | 'meshanimation-delete'
    | 'label-create'
    | 'label-delete'
    | 'label-visible'
    | 'label-caption'
    | 'label-offset'
    | 'label-charheight'
    | 'label-color'
    | 'label-ontop'
    | 'canvas-create'
    | 'canvas-delete'
    | 'canvas-visible'
    | 'canvas-zorder'
    | 'canvas-passive'
    | 'canvas-updatebuffer'
    | 'canvas-size'
    | 'canvas-offset'
    | 'canvas-resolution'
    | 'canvas-inview'
    | 'view-create'
    | 'view-delete'
    | 'view-fov'
    | 'view-nearclip'
    | 'view-farclip'
    | 'view-offset'
    | 'view-orientation'
    | 'physical-create'
    | 'physical-delete'
    | 'physical-collision'
    | 'physical-debugdraw'
    | 'interpolator-info'
    | 'render-windowsize'
    | 'render-fullscreen'
    | 'render-maximize'
    | 'render-displayposition'
    | 'render-window-show'
    | 'render-window-hide'
    | 'render-window-enter'
    | 'render-window-leave'
    | 'render-cursor'
    | 'render-request-raytest'
    | 'spatialctrl-enable'
    | 'spatialctrl-state'
    | 'render-crosshair-enable'
    | 'render-crosshair-props'
    | 'render-fpspanel'
    | 'render-skybox'
    | 'render-sceneambient'
    | 'render-viewportbackground'
    | 'render-fog'
    | 'render-resource-create'
    | 'render-resource-add'
    | 'render-resource-init'
    | 'core-quit';

  type WomEventDescriptor =
    | WomCoreEventDescriptor
    | NodeMouseEventDesciptor
    | NodeMouseWheelEventDescriptor
    | WomInsertedEventDescriptor
    | WomLoadingStateChangedEventDescriptor
    | WomUnLoadingStateChangedEventDescriptor
    | WomUnLoadingStateChangedEventDescriptor
    | WomResizeEventDescriptor
    | WomDPIChangeEventDescriptor
    | WomDPIChangeEventDescriptor
    | WomKeyboardEventDescriptor
    | WomInputTextEventDescriptor
    | WomCommonEventDescriptor;

  type WomCommonEventDescriptor =
    | WomCommonEventName
    | {
        type: WomCommonEventName;
        subject?: string;
        object?: Node;
      };

  type WomCommonEventObject = {
    /**
     * Event group name. Events are group by usage categories. Event name prefix in eventName is identical to group name.
     */
    group: string;
    /**
     * Event type name. Possible values are the same as for eventName.
     */
    type: string;
    /**
     * Name of event's subject. Only 3D object related events using valid name here
     */
    subject: string;
  };

  type WomInputTextEventDescriptor =
    | 'input-text'
    | {
        type: 'input-text';
        subject?: string;
        object?: Node;
      };

  type WomInputTextEventObject = {
    /**
     * Input text.
     */
    text: string;
  };

  type WomKeyboardEventDescriptor =
    | 'input-keyboard'
    | {
        type: 'input-keyboard';
        subject?: string;
        object?: Node;
      };

  type WomKeyboardEventObject = {
    /**
     * Action type name. Possible values: keyDown, keyUp.
     */
    type: 'keyDown' | 'keyUp';
    /**
     * Key code representation of key.
     */
    keyCode: number;
    /**
     *  Scan code representation of key.
     */
    scanCode: number;
    /**
     * Name of key.
     */
    keyName: string;
    /**
     * Is Shift key pressed.
     */
    modShift: boolean;
    /**
     *  Is Ctrl key pressed.
     */
    modCtrl: boolean;
    /**
     * Is Alt key pressed.
     */
    modAlt: boolean;
    /**
     *  Is Gui key pressed (a.k.a. meta key, command on macOS, win key on Windows).
     */
    modGui: boolean;
    /**
     * Is NumLock on.
     */
    modNum: boolean;
    /**
     * Is CapsLock on.
     */
    modCaps: boolean;
  };

  type WomDPIChangeEventDescriptor =
    | 'dpi-change'
    | {
        type: 'dpi-change';
        subject?: string;
        object?: Node;
      };

  type WomDPIChangeChangedEventObject = {
    /**
     * New scale factor
     */
    dpi: number;
  };

  type WomResizeEventDescriptor =
    | 'resize'
    | {
        type: 'resize';
        subject?: string;
        object?: Node;
      };

  type WomResizeEventObject = {
    /**
     * New window width in pixels
     */
    w: number;
    /**
     * New window height in pixels
     */
    h: number;
  };

  type WomUnLoadingStateChangedEventDescriptor =
    | 'unloading-state-changed'
    | {
        type: 'unloading-state-changed';
        subject?: string;
        object?: Node;
      };

  type WomUnLoadingStateChangedEventObject = {
    /**
     * Number of already unloaded Mesh objects
     */
    unloaded: number;
    /**
     * Total number of Mesh objects to unload
     */
    total: number;
    /**
     * Current state of Mesh unloading process in [0-1] interval
     */
    percent: number;
  };

  type WomLoadingStateChangedEventDescriptor =
    | 'loading-state-changed'
    | {
        type: 'loading-state-changed';
        subject?: string;
        object?: Node;
      };

  type WomLoadingStateChangedEventObject = {
    /**
     * Number of already loaded Mesh objects
     */
    loaded: number;
    /**
     * Total number of Mesh objects to load
     */
    total: number;
    /**
     * Current state of Mesh loading process in [0-1] interval
     */
    percent: number;
  };

  type WomInsertedEventHandler = (
    /**
     *  The inserted Node object
     */
    node: Node,
  ) => void;

  type WomInsertedEventDescriptor =
    | 'inserted'
    | {
        type: 'inserted';
        subject?: string;
        object?: Node;
      };
  type NodeMouseWheelEventDescriptor =
    | NodeMouseWheelEventName
    | {
        type: NodeMouseWheelEventName;
        subject?: string;
        object?: Node;
      };

  type WomCoreEventDescriptor =
    | WomCoreEventName
    | {
        type: WomCoreEventName;
        subject?: string;
        object?: Node;
      };

  type WomCoreEventName =
    | NodeCoreEventName
    | 'native ready'
    | 'ready'
    | 'clear-complete'
    | 'before-close'
    | 'after-close'
    | 'quit';

  type NodeMouseEventDesciptor =
    | NodeMouseEventName
    | {
        type: NodeMouseEventName;
        subject?: string;
        object?: Node;
      };

  interface Color {
    r: number;
    g: number;
    b: number;
    a?: number;
  }

  type LightType = 'spot' | 'directional' | 'point';
  type Range = { inner_angle: number; outer_angle: number; falloff: number };
  type Attenuation = {
    range: number;
    constant: number;
    linear: number;
    quadratic: number;
  };

  /**
   * Lighsource in 3d scene.
   *
   * Light is subclass of Node. It adds 'light' type entity to Node base class and provides accessor and manipulator functions for light as extension. 'light' type entities are light sources in the 3d scene and illuminates Mesh objects.
   */
  export type Light = ProtoExntends<Node, LightExt>;
  interface LightExt {
    /**
     * Sets the type of Light.
     * @param type String - Light type to set. Possible values are: spot, directional, point.
     */
    setType(type: LightType): this;
    /**
     * @returns String the type of Light. Possible values are: spot, directional, point.
     */
    getType(): LightType;
    /**
     * Sets the diffuse color of Light.
     *
     * Diffuse light simulates the typical light emanating from light sources and affects the base colour of objects together with ambient light.
     * @param r Number - Red component of color. Range in [0, 1].
     * @param g Number - Green component of color. Range in [0, 1].
     * @param b Number - Blue component of color. Range in [0, 1].
     * @param a Number - Alpha component of color. Range in [0, 1].
     */
    setDiffuse(r: number, g: number, b: number, a: number): this;
    /**
     * @returns Object {r, g, b, a} - The diffuse color of Light.
     * Diffuse light simulates the typical light emanating from light sources and affects the base colour of objects together with ambient light.
     */
    getDiffuse(): Color;
    /**
     * Sets the specular color of Light.
     *
     * Specular light affects the appearance of shiny highlights on objects, and is also dependent on the 'shininess' Material value.
     * @param r Number - Red component of color. Range in [0, 1].
     * @param g Number - Green component of color. Range in [0, 1].
     * @param b Number - Blue component of color. Range in [0, 1].
     * @param a Number - Alpha component of color. Range in [0, 1].
     */
    setSpecular(r: number, g: number, b: number, a: number): this;
    /**
     * @returns Object {r, g, b, a} - The specular color of Light.
     * Specular light affects the appearance of shiny highlights on objects, and is also dependent on the 'shininess' Material value.
     */
    getSpecular(): Color;
    /**
     * Sets the attenuation coefficients of Light. The attenuation formula will be calculated using the given values. Attenuation refers to how the lightsource diminishes with distance.
     * @param range Number - Absolute upper range of the Light.
     * @param constant Number - Constant factor in the attenuation formula. Range in [0, 1]. 1.0 means never attenuate, 0.0 is complete attenuation.
     * @param linear Number (optional) - Linear factor in the attenuation formula. Range in [0, 1]. 1.0 means attenuate evenly over the distance. If not provided it's calculated automatically (4.5 / range)
     * @param quadratic Number (optional) - Quadratic factor in the attenuation formula which adds a curvature to the attenuation formula. If not provided it's calculated automatically (75.0 / range^2)
     *
     *  Applicable only to 'spot' and 'point' types
     */
    setAttenuation(
      range: number,
      constant: number,
      linear?: number,
      quadratic?: number,
    ): this;
    /**
     * @returns Object {range, constant, linear, quadratic} - Attenuation coefficients of Light. The attenuation formula is calculated using the returned values. Attenuation refers to how the lightsource diminishes with distance.
     * Available only for 'spot' and 'point' types
     */
    getAttenuation(): Attenuation;
    /**
     * Sets the range of spot type Light. Range refers to the angle of the inner and outer cones the spotlight illuminates and the rate of falloff between them.
     * @param inner_angle Number | Object
     *
     * Angle of inner cone of illumination to set (Degree)
     * Range properties to set as {inner_angle, outer_angle, falloff}. If given as Object, outer_angle, falloff parameters are ignored.
     * @param outer_angle Number - Angle of outer cone of illumination to set (Degree)
     * @param falloff Number - Rate of falloff to set. 1.0 means a linear falloff, less means slower falloff, higher means faster falloff.\
     *
     *  Applicable only to 'spot' type
     */
    setRange(
      inner_angle:
        | number
        | { inner_angle: number; outer_angle: number; falloff: number },
      outer_angle?: number,
      falloff?: number,
    ): this;
    /**
     * @returns Object {inner_angle, outer_angle, falloff} - The range of the spot type Light. Range refers to the angle of the inner and outer cones the spotlight illuminates (in Degrees) and the rate of falloff between them.
     *
     * Available only for 'spot' type
     */
    getRange(): Range;
    /**
     * Sets the direction vector of the Light.
     * @param x Number - x component of direction vector to set
     * @param y Number - y component of direction vector to set
     * @param z Number - z component of direction vector to set
     *
     * Applicable only to 'spot' and 'directional' types
     */
    setDirection(x: number, y: number, z: number): this;
    /**
     * @returns Object {x, y, z} - The direction vector of Light
     *
     * Available only for 'spot' and 'directional' types
     */
    getDirection(): Vector3;
    /**
     * Turn on the light source in 3d scene.
     */
    show(): this;
    /**
     * Turn off the light source in 3d scene.
     */
    hide(): this;
    /**
     * For basic operation of the function see documentation of Node.animate(attribute, options[, complete]). Light extends the method with further available attributes.
     * @param attribute String - Additional attributes can be used: diffuse, specular, range, attenuation. Matching values are Object {r, g, b, a} for diffuse, specular, Object {inner_angle, outer_angle, falloff} for range and Object {range, constant, linear, quadratic} for attenuation
     */
    /**
     *
     * @param attribute Transformation type. Possible values are position, scale, orientation. Matching values are Object {x, y, z} for position, scale and Object {w, x, y, z} or {angle, axis} for orientation
     * @param options Options determining the run of the animation.
     * @param complete Callback for completed animation. If repeat is true the animation will be completed only if stopped manually.
     */
    animate(
      attribute: 'position' | 'scale',
      options: {
        /**
         * Start values of the animated attribute for every step. If it's omitted it will animate from the actual value of the attribute. Otherwise the length of array should be equal to number of animation steps.
         */
        from?: Vector3 | Array<Vector3>;
        /**
         * End values of the animated attribute for every step. The length of array should be equal to number of animation steps.
         */
        to: Vector3 | Array<Vector3>;
        /**
         * Duration of every animation steps in seconds. If animating through multiple steps but only one duration is provided, it will be used for every step. Otherwise the length of array should be equal to number of animation steps.
         */
        duration: number | Array<number>;
        /**
         *  Repeat the animation for ever. Default is false.
         */
        repeat?: boolean;
        /**
         * Loop the animation for ever. Animation will be played, then played backwards and repeated (overrides repeat if given contradictory). Default is false.
         */
        loop?: boolean;
        /**
         * The cubic easing function of the animation which defines the curve of temporal run.
         */
        cubic?: Bezier | EasingFunction;
        /**
         * Reference of the attribute adjustment.
         */
        reference?: Reference;
        /**
         *  Space the attribute adjustment is applied in.
         */
        space?: Space;
      },
      complete?: Function,
    ): this;
    animate(
      attribute: 'orientation',
      options: {
        /**
         * Start values of the animated attribute for every step. If it's omitted it will animate from the actual value of the attribute. Otherwise the length of array should be equal to number of animation steps.
         */
        from?: Quaternion | AngleAxis | Array<Quaternion | AngleAxis>;
        /**
         * End values of the animated attribute for every step. The length of array should be equal to number of animation steps.
         */
        to: Quaternion | AngleAxis | Array<Quaternion | AngleAxis>;
        /**
         * Duration of every animation steps in seconds. If animating through multiple steps but only one duration is provided, it will be used for every step. Otherwise the length of array should be equal to number of animation steps.
         */
        duration: number | Array<number>;
        /**
         *  Repeat the animation for ever. Default is false.
         */
        repeat?: boolean;
        /**
         * Loop the animation for ever. Animation will be played, then played backwards and repeated (overrides repeat if given contradictory). Default is false.
         */
        loop?: boolean;
        /**
         * The cubic easing function of the animation which defines the curve of temporal run.
         */
        cubic?: Bezier | EasingFunction;
        /**
         * Reference of the attribute adjustment.
         */
        reference?: Reference;
        /**
         *  Space the attribute adjustment is applied in.
         */
        space?: Space;
      },
      complete?: Function,
    ): this;
    animate(
      attribute: 'diffuse' | 'specular',
      options: {
        /**
         * Start values of the animated attribute for every step. If it's omitted it will animate from the actual value of the attribute. Otherwise the length of array should be equal to number of animation steps.
         */
        from?: Color | Array<Color>;
        /**
         * End values of the animated attribute for every step. The length of array should be equal to number of animation steps.
         */
        to: Color | Array<Color>;
        /**
         * Duration of every animation steps in seconds. If animating through multiple steps but only one duration is provided, it will be used for every step. Otherwise the length of array should be equal to number of animation steps.
         */
        duration: number | Array<number>;
        /**
         *  Repeat the animation for ever. Default is false.
         */
        repeat?: boolean;
        /**
         * Loop the animation for ever. Animation will be played, then played backwards and repeated (overrides repeat if given contradictory). Default is false.
         */
        loop?: boolean;
        /**
         * The cubic easing function of the animation which defines the curve of temporal run.
         */
        cubic?: Bezier | EasingFunction;
        /**
         * Reference of the attribute adjustment.
         */
        reference?: Reference;
        /**
         *  Space the attribute adjustment is applied in.
         */
        space?: Space;
      },
      complete?: Function,
    ): this;
    animate(
      attribute: 'range',
      options: {
        /**
         * Start values of the animated attribute for every step. If it's omitted it will animate from the actual value of the attribute. Otherwise the length of array should be equal to number of animation steps.
         */
        from?: Range | Array<Range>;
        /**
         * End values of the animated attribute for every step. The length of array should be equal to number of animation steps.
         */
        to: Range | Array<Range>;
        /**
         * Duration of every animation steps in seconds. If animating through multiple steps but only one duration is provided, it will be used for every step. Otherwise the length of array should be equal to number of animation steps.
         */
        duration: number | Array<number>;
        /**
         *  Repeat the animation for ever. Default is false.
         */
        repeat?: boolean;
        /**
         * Loop the animation for ever. Animation will be played, then played backwards and repeated (overrides repeat if given contradictory). Default is false.
         */
        loop?: boolean;
        /**
         * The cubic easing function of the animation which defines the curve of temporal run.
         */
        cubic?: Bezier | EasingFunction;
        /**
         * Reference of the attribute adjustment.
         */
        reference?: Reference;
        /**
         *  Space the attribute adjustment is applied in.
         */
        space?: Space;
      },
      complete?: Function,
    ): this;

    animate(
      attribute: 'attenuation',
      options: {
        /**
         * Start values of the animated attribute for every step. If it's omitted it will animate from the actual value of the attribute. Otherwise the length of array should be equal to number of animation steps.
         */
        from?: Attenuation | Array<Attenuation>;
        /**
         * End values of the animated attribute for every step. The length of array should be equal to number of animation steps.
         */
        to: Attenuation | Array<Attenuation>;
        /**
         * Duration of every animation steps in seconds. If animating through multiple steps but only one duration is provided, it will be used for every step. Otherwise the length of array should be equal to number of animation steps.
         */
        duration: number | Array<number>;
        /**
         *  Repeat the animation for ever. Default is false.
         */
        repeat?: boolean;
        /**
         * Loop the animation for ever. Animation will be played, then played backwards and repeated (overrides repeat if given contradictory). Default is false.
         */
        loop?: boolean;
        /**
         * The cubic easing function of the animation which defines the curve of temporal run.
         */
        cubic?: Bezier | EasingFunction;
        /**
         * Reference of the attribute adjustment.
         */
        reference?: Reference;
        /**
         *  Space the attribute adjustment is applied in.
         */
        space?: Space;
      },
      complete?: Function,
    ): this;
  }

  type LightOptions = ProtoExntends<NodeOptions, LightOptionsExt>;
  interface LightOptionsExt {
    /**
     * The light's type. Possible values are: spot, directional, point (default).
     */
    lighttype?: LightType;
    /**
     * The diffuse color of the light {r, g, b, a}. Default is {r: 1.0, g: 1.0, b: 1.0, a: 1.0}.
     */
    diffuse?: Color;
    /**
     * The specular color of the light {r, g, b, a}. Default is {r: 1.0, g: 1.0, b: 1.0, a: 1.0}.
     */
    specular?: Color;
    /**
     *  The range parameters of the light source {inner_angle: Number (Degree), outer_angle: Number (Degree),
     */
    range?: Range;
    /**
     * The attenuation coefficients of the light source {range, constant, linear, quadratic}, where properties are positive Numbers (constant is in range [0, 1]). Default is {range: 5000, constant: 1, linear: 0.0009, quadratic: 0.000003}, .
     */
    attenuation?: Attenuation;
    /**
     * The 3D vector towards the light will point {x, y, z}. Default is {x: 0, y: -1, z: 0}.
     */
    direction?: Vector3;

    done?: (node: Light) => void;
  }

  export type MeshOptions = ProtoExntends<NodeOptions, MeshOptionsExt>;

  interface InstancedMeshOptions extends MeshOptions {}
  interface MeshOptionsExt {
    /**
     * Name of Ogre mesh file.
     */
    url: string;
    /**
     * Path to Ogre mesh file. If not defined, resource folders are used.
     */
    meshFolder?: string;

    done?: (node: Mesh) => void;
  }
  interface NodeOptions {
    /**
     * A unique identifier for a node among other nodes. Default is autogenerated.
     */
    id?: string;
    /**
     * Determines the class of a node for querying. For mulitple classes separate them with ' '. Default is empty
     */
    class?: string;
    /**
     *  The Node's position in 3d scene. Default is {x: 0.0, y: 0.0, z: 0.0}. Partial object definitions are completed with default property values
     */
    position?: Vector3;
    /**
     * Node's orientation in 3d scene. Default is {w: 1.0, x: 0.0, y: 0.0, z: 0.0}.
     */
    orientation?: Quaternion | AngleAxis;
    /**
     *  The Node's scale along axes. If one Number is provided it will be used for every axis. Default is {x: 1.0, y: 1.0, z: 1.0}.
     */
    scale?: Vector3 | number;
    /**
     * Whether to generate a simple physical shape for the Node. Default is false.
     */
    autophysical?: boolean;
    /**
     *  A callback that executes, when the Node is successfully inserted into the 3d scene. Default is no operation.
     */
    done?: (node: Node) => void;
    /**
     * The physical description of the Node.
     */
    physical?: Physical;
  }

  interface Physical {
    /**
     * Type of physical representation of Node. Possible values are static, dynamic, kinematic, ghost (default).
     */
    'link-type'?: LinkType;
    /**
     * Whether the physical is pointable by mouse. Default is false.
     */
    raycast?: boolean;
    /**
     * Whether Node receive collision events. Default is false.
     */
    collision?: boolean;
    /**
     *  Dynamic properties of physical
     */
    coefficients?: Coeffs;

    shapes?: PhysicalShape[];
  }

  /**
   * Canvas object which renders a Chromium webview.
   * Webview is subclass of Canvas and Node. It extends Canvas with the capability of rendering Chromium webview into the underlying texture. Required browsing facilities are implemented in this class. It instantiates an offscreen electron Electron.BrowserWindow and sends the webview buffer into inherited Canvas texture.
   * @extends Canvas
   */
  export type Webview = ProtoExntends<Canvas, WebviewExt>;
  interface WebviewExt {
    /**
     *  The electron Electron.BrowserWindow rendering into Webview
     */
    browserWindow: Electron.BrowserWindow;
    /**
     * A Boolean showing whether the Webview is ready and initial URL is loaded.
     */
    isReady: boolean;
    /**
     * A Boolean showing whether mouse input is disabled for Electron.BrowserWindow.
     */
    mouseInputDisabled: boolean;
    /**
     * A Boolean showing whether keyboard input is disabled for Electron.BrowserWindow.
     */
    keyboardInputDisabled: boolean;
    /**
     * A Boolean showing whether mouse is over the in-game type Webview.
     */
    isMouseOver: boolean;
    /**
     * A Boolean showing whether Electron.BrowserWindow recieves any key event or only those emitted while the mouse hovers the Webview.
     */
    directKeyEvent: boolean;

    props: {
      /**
       * The currently loaded URL of Electron.BrowserWindow
       */
      url: string;
    };
    /**
     * URL of current favicon of Electron.BrowserWindow's page
     */
    favicon: string;
    /**
     * Loads an URL into Electron.BrowserWindow of Webview
     * @param url String - The URL to load
     * @param options Object (optional) - Options passed to electron WebContents.loadURL
     */
    loadURL(url: string, options?: Electron.LoadURLOptions): this;
    /**
     * Sets the resolution both for Canvas and Electron.BrowserWindow.
     * @param width Number - The resolution width in pixels (Integer) to set.
     * @param height Number - The resolution height in pixels (Integer) to set.
     *
     * Pixels scale factor is calculated to the resolution automatically
     */
    setResolution(width: number, height: number): this;
    /**
     * Sets the pixel scale factor of Electron.BrowserWindow.
     * @param factor Number (positive) - The pixel scale factor to set.
     *
     * Resets resolution to apply new scale factor
     */
    setPixelScaleFactor(factor: number): this;
    /**
     * Shows this entity in 3d scene or on overlay. Electron.BrowserWindow starts painting. Contrary to Node method it manipulates the canvas type entity instead of base node.
     */
    show(): this;
    /**
     * Hides this entity in 3d scene or on overlay. Electron.BrowserWindow stops painting. Contrary to Node method it manipulates the canvas type entity instead of base node.
     */
    hide(): this;
    /**
     * Deletes this entity and the corresponding Electron.BrowserWindow.
     */
    clear(): this;
    /**
     * Enables mouse input handling of Electron.BrowserWindow.
     */
    enableMouseInput(): this;
    /**
     * Enables keyboard input handling of Electron.BrowserWindow.
     */
    enableKeyboardInput(): this;
    /**
     * Disables mouse input handling of Electron.BrowserWindow.
     */
    disableMouseInput(): this;
    /**
     * Disables keyboard input handling of Electron.BrowserWindow.
     */
    disableKeyboardInput(): this;
    /**
     * Enables mouse and keyboard input handling of Electron.BrowserWindow.
     */
    enableInput(): this;
    /**
     * Disables mouse and keyboard input handling of Electron.BrowserWindow.
     */
    disableInput(): this;
    /**
     * Sets the Electron.BrowserWindow which renders into Webview. If replace is required removes registered listeners on previous one.
     * @param win Electron.BrowserWindow - electron Electron.BrowserWindow to set for rendering
     */
    setBrowserWindow(win: Electron.BrowserWindow): this;

    //TODO listeners
    on(eventName: NodeCoreEventName, handler: Function): this;
    on(
      eventName: NodeMouseEventName,
      handler: (event: NodeMouseEventObject) => void,
    ): this;
    on(
      eventName: NodeMouseWheelEventName,
      handler: (event: NodeMouseWheelEventObject) => void,
    ): this;

    once(
      eventName: NodeMouseEventName,
      handler: (event: NodeMouseEventObject) => void,
    ): this;
    once(
      eventName: NodeMouseWheelEventName,
      handler: (event: NodeMouseWheelEventObject) => void,
    ): this;

    once(eventName: NodeCoreEventName, handler: Function): this;

    //TODO listeners

    on(
      eventName: 'canvas-new-size' | 'ready' | 'favicon-update-successful',
      handler: Function,
    ): this;
    once(
      eventName: 'canvas-new-size' | 'ready' | 'favicon-update-successful',
      handler: Function,
    ): this;

    /**
     * Unregisters an event listener for the specified event. Handler function should be identical to the one which used to register the listener. That is it's not enough to have the same function body they should be the same javascript object. Consequently equivalent lambdas are not accepted
     * @param eventName Event type descriptor
     * @param handler  Handler function taking event as argument where event is an Object containing different properties according to the event type.
     */
    removeListener(
      eventName:
        | NodeEventName
        | 'canvas-new-size'
        | 'ready'
        | 'favicon-update-successful',
      handler: Function,
    ): this;
  }

  /**
   * Overlay type Webview object
   * Overlay is subclass of Webview. It implements Webview rendered into the overlay of native display. Provides functions for special needs of overlay type Webview. It doesn't have any physical representation in 3d scene.
   * @extends Webview
   */
  export interface Overlay extends Webview {
    /**
     * Injects the given node to the scope of its chromium webview in the window[name] global. Emits a '${name}-ready' event in the webview's scope on the process object.
     */
    injectNode(name: string, node: Node): this;
  }

  export type OverlayOptions = ProtoExntends<WebviewOptions, OverlayOptionsExt>;
  interface OverlayOptionsExt {
    done?: (node: Overlay) => void;
    show?: boolean;
  }

  export interface Component {
    nativeRender?: Node;
    overlayURL?: string;
    overlayNode?: Node;

    init: (opts: object) => void;
    done: (node: Component) => void;
    render: (props: object, children?: Node) => void;
    clear: () => void;
  }

  /**
   * A Webtable with ready-only content
   *
   * Billboard is a specific type of Webtable, which initialized with the following properties
   *
   * urlControls: false
   *
   * transparent is true by default (contrary to Webtable)
   *
   * As a result, Billboards have no navigation bar UI, but is a fully functional Webtable instance in any other sense.
   */
  export interface Billboard extends Webtable {}

  export type BillBoardOptions = ProtoExntends<
    WebtableOptions,
    BillBoardOptionsExt
  >;
  interface BillBoardOptionsExt {
    done?: (billboard: Billboard) => void;
  }

  /**
   * A Component consists of a Webview and UI Overlays implementing a web browser with special features.
   * Webtables can be used without any further adjustment. Mouse and keyboard inputs are handled automatically. UI Overlays are opening when the Webview is selected in the 3d scene by click or double click. UI contains navigation and editing tools to use wecontent or local files in the webview. Ways of how the user can interact with the Webtable are adjustable as well via instance methods.
   */
  export type Webtable = ProtoExntends<Component, WebtableExt>;
  export interface WebtableExt {
    /**
     * The Webview of the webtable. Provides access to the displayed content.
     */
    webview: Webview;
    /**
     * A Number indicating the index of webtable, which is used as a reference to this instance
     */
    index: number;
    /**
     * Boolean indicating whether the webtable is in selected state. In selected state the webview is activated in 3d scene and control UI overlays are visible
     */
    isSelected: boolean;
    /**
     * Boolean indicating whether the webtable is in zoomed-in state. When zoomed, the webview is activated on the overlay and control UI elements are visible
     */
    isZoomedIn: boolean;
    /**
     * String containing the pinned URL, which can be loaded with 'Return to Pin' and overwritten with 'Pin'. Considered as the user's personal saved URL
     */
    savedURL: string;
    /**
     * String containing the factory default URL, which can be loaded with 'Return to default'. Considered as the Home URL defined by the designer of the Where
     */
    factoryURL: string;
    /**
     * Boolean defining whether URL control UI overlay bar should be created to this webtable. Without URL control bar the content of the webview cannot be changed. (See Billboard) Default is true
     */
    urlControls: boolean;
    /**
     * Object storing the zoom parameters in case of auto-generated resolution. Parameters are calculated from the active display's resolution, pixel scale factor and webview's size. When zoomed, the webview will have the same pixel size as the covered area on the display
     *
     * width Number - Width of fitting are in pixels
     *
     * height Number - Height of fitting area in pixels
     *
     * x Number - Position of fitting area on screen's vertical axis
     *
     * y Number - Position of fitting area on screen's horizontal axis
     */

    zoomFitArea: Electron.Rectangle;
    /**
     * Object containing the GA info inserted into maxwhere pages when one is loaded
     */
    gaInfo: object;
    /**
     * Boolean indicating whether this webtable should be excluded from bundle export.
     */
    private: boolean;
    /**
     * Persistent Node which serves as a root for UI element overlays. Overlays added onto this node cannot be deleted, thus they persist between Wheres
     */
    baseNode: Node;
    /**
     * Overlay on which the webview content is rendered in case of auto-generated resolution
     */
    zoomOverlay: Overlay;
    /**
     * Overlay used for displaying toast messages of the webtable
     */
    messageArea: Overlay;
    /**
     * Overlay containing the Exit and Zoom buttons below the navigation bar
     */
    statusBar: Overlay;
    /**
     * Overlay used for displaying tooltip texts for navigation bar and status bar buttons
     */
    tooltipOverlay: Overlay;
    /**
     * Overlay used for authentication when a webpage requests one
     */
    authBar: Overlay;
    /**
     * Overlay containing the navigation buttons (Reload, Back, etc.), utility buttons (Pin, Default, etc.) and URL input on the top bar of the screen
     */
    navigationBar: Overlay;
    /**
     * Moves the camera to webview of this webtable and focus on it by enabling inputs on it and opening UI overlays for manipulation. Camera pose is calculated from Webview dimensions.
     * @param done Function (optional) - Called after the webtable is successfully zoomed in
     */
    zoomIn(done?: Function): this;
    /**
     * Moves the camera back away from webview of this webtable and unfocus it by disabling inputs on it and closing UI overlays. Camera moves to the pose which preceded the zooming.
     * @param animate Boolean (optional) - Whether the camers should be animated on its path back.
     */
    zoomOut(animate: boolean): this;
    /**
     * Moves the camera back away from webview of this webtable and keeps it selected (UI overlays remains visible)
     */
    zoomBack(): this;
    /**
     * Shows navigation and status bar overlays. If urlControls is disabled navigation bar is not shown
     */
    showControls(): this;
    /**
     * Hides navigation and status bar overlays.
     */
    hideControls(): this;
    /**
     * Hides every overlay in wom which not belongs to this webtable
     */
    hideOtherOverlays(): this;
    /**
     * Shows overlays in wom which are temporary hidden by hideOtherOverlays
     */
    reshowOtherOverlays(): this;
    /**
     * Focuses input on the webview of this webtable. Internal function, use select for full state change
     */
    focus(): this;
    /**
     * Unfocuses input on the webview of this webtable. Internal function, use unselect for full state change
     */
    blur(): this;
    /**
     * Selects this webtable. Gives input focus to the webview and opens UI overlays for manipulation.
     */
    select(): this;
    /**
     * Removes selected state of this webtable. Removes input focus of the webview and closes UI overlays.
     */
    deselect(): this;
    /**
     * @returns Boolean indicating whether the webview size of this webtable is considered vertical. If height is greater than 1.25 * width, the webview is considered vertical
     */
    isVertical(): boolean;
    /**
     * Unfocusing this webtable by either zooming out from it (if isZoomedIn) or deselect it (if not isZoomedIn).
     * @param animate Boolean (optional) - Whether the camers should be animated on its path back.
     */
    zoomOutOrDeselect(animate?: boolean): this;
    /**
     * Approaching the webview of this webtable with the camera or moves the camera back to its previous position. When approached, the webview is visible in front of the camera but rendering is not forwarded to the zoomOverlay and UI overlays are not opened.
     */
    approachOrPullBack(): this;
    /**
     * Moves camera to the webview of this webtable or away from it. The movement depends on the current state of the webtable. Internal function, use select/unselect/zoomIn/zoomOut for full state change along with the camera animation
     * @param done Function (optional) - Called when the camera movement is done.
     */
    animateCamera(done?: Function): this;
    /**
     * Changes URL displayed in navigation bar overlay. Internal function, actual content load of loadWebviewURL/safeLoadWebviewURL will chage the displayed URL anyway
     * @param url  - URL to display on navigation bar
     */
    changeURL(url: string): this;
    /**
     * @returns MXWUrl the content URL of the currently active webtable. The returned URL is dehandled, thus can contain protocols meaningful only in maxwhere
     */
    currentURL(): string;
    /**
     * Navigates the content of webview back with one entry in the browsing history (if any).
     */
    goBackInHistory(): this;
    /**
     * Navigates the content of webview forward with one entry in the browsing history (if any).
     */
    goForwardInHistory(): this;
    /**
     * Reloads the current content of the webview. Safe means it won't wait the operation to finish for ever (timeout limit is 10 s)
     * @returnsdone Function (optional) - Called when reload was successful or the time limit has passed.
     * @alias reload()
     */
    safeReload(done?: Function): this;
    /**
     * Loads the specified URL to the webview of this webtable
     * @param url String | MXWUrl - URL to load to the webview
     * @param opts Object {urlOptions, force} (optional) - Options of operation. force ignores any URL handling before load and urlOptions are passed to Webview.loadURL
     */
    loadWebviewURL(
      url: string,
      opts?: { force: boolean; urlOptions: Electron.LoadURLOptions },
    ): this;
    /**
     * Loads the specified URL to the webview of this webtable. Safe means it won't wait the operation to finish for ever (timeout limit is 10 s)
     * @param url String | MXWUrl - URL to load to the webview
     * @param opts Object {urlOptions, force} (optional)- Options of operation. force ignores any URL handling before load and urlOptions are passed to Webview.loadURL
     * @param done Function (optional) - Called when load URL was successful (DOM of page is ready) or the time limit has passed.
     */
    safeLoadWebviewURL(
      url: string,
      done?: Function,
      opts?: { force: boolean; urlOptions: Electron.LoadURLOptions },
    ): this;
    /**
     * Sets whether moving the mouse to the edges of the native window should deselect webtable or not. Not meant to be used directly as it's overwritten by many internal behavior
     *  @param enable Boolean - Enable or disable hot edge feature
     */
    setHotEdges(enable: boolean): this;
    /**
     * Pins the current URL. That is the current URL will be stored as savedURL. Action button is available on navigation bar
     */
    pin(): this;
    /**
     * Safely loads savedURL into the webview. 'Pin' button is available on navigation bar
     * @param done Function (optional) - Called when the content is successfully loaded.
     */
    pinReturn(done?: Function): this;
    /**
     * Safely loads factoryURL into the webview. 'Return to default' button is available on navigation bar
     * @param done Function (optional) - Called when the content is successfully loaded.
     */
    setFactoryURL(done?: Function): this;
    /**
     * Sets factoryURL. factoryURL can be loaded with 'Return to default' button on navigation bar
     */
    resetFactoryURL(): this;
    /**
     * Sets the zoomed-in state of this webtable. Not meant to be used directly. State changes are handled by higher level functions automatically
     * @param zoomed Boolean - Zoomed-in state to set
     */
    setZoomedIn(zoomed: boolean): this;
    /**
     * Redirects content rendering from 3d webview onto the zoomOverlay. For getting a crispy look, the pixels size of the covered area should match the screens resolution. Calculated values of zoomFitArea contains these properties. Otherwise, any resolution and webview texture filtering can be used.
     * @param enable Boolean - Whether to enable or disable rendering on zoomOverlay
     */
    redirectPaint(enable: boolean): this;
  }

  type WebtableOptions = ProtoExntends<WebviewOptions, WebtableOptionsExt>;
  interface WebtableOptionsExt {
    /**
     * Index number of webtable, which is used as a reference to this webtable instance (and displayed on default maxwhere page).
     */
    index?: number;
    /**
     * GA info to insert into maxwhere pages when one is loaded. Order of object properties should follow the specified order
     */
    gaInfo?: object;
    /**
     * Whether this webtable should be excluded from bundle export.
     */
    private?: boolean;
    /**
     * Whether the resolution of the webview should be automatically calculated from the resolution and pixel scale factor of the containing display. If defined, 'resolution-width' and 'resolution-height' options will not be applied. The auto-generated resolution will precisely match the covered screen resolution in zoomed-in state
     */
    'auto-resolution'?: boolean;
    /**
     * Whether to create URL control UI overlay bar to this webtable. Without URL control bar the content of the webview cannot be changed. (See Billboard) Default is true
     */
    urlControls?: boolean;
    /**
     * Pinned URL, which can be loaded with 'Return to Pin' and overwritten with 'Pin'. Considered as the user's personal saved URL
     */
    savedURL?: string;
    /**
     * Factory default URL, which can be loaded with 'Return to default'. Considered as the Home URL defined by the designer of the Where
     */
    factoryURL?: string;
    /**
     * Current URL to load after webtable is successfully initialized. Default is maxwhere default page (overrides Webview default).
     */
    url?: string;
    /**
     * Path(s) of preload script(s) used in webtable's webview (overrides Webview option to accept multiple preload scripts)
     */
    preload?: string | string[];

    done?: (node: Webview) => void;
  }

  interface WebviewOptions extends CanvasOptions {
    /**
     * URL to load. Default is 'about:blank'
     */
    url?: string;
    /**
     * Disable mouse and key inputs for Electron.BrowserWindow of this Webview. Default is true.
     */
    inputDisabled?: boolean;
    /**
     *  Determines whether the Electron.BrowserWindow of Webview is listening for any key event (false) or only for those emitted while the mouse hovers the Webview (true). Hover is detected either by physical shape (in-game) or mouse position intersection (overlay) Default is true.
     */
    directKeyEvent?: boolean;
    /**
     * Enable node integration in Electron.BrowserWindow of Webview. Default is false.
     */
    nodeIntegration?: boolean;
    /**
     * Enable web security in Electron.BrowserWindow of Webview. Default is true.
     */
    webSecurity?: boolean;
    /**
     * Pixel scale factor of Electron.BrowserWindow. Default is the scale factor of native window (or 1 if that's not available).
     */
    scaleFactor?: number;
    /**
     * Path of preload script for Electron.BrowserWindow. The script is loaded before anything else on the page.
     */
    preload?: string;
    /**
     * Electron.Session used by the Electron.BrowserWindow. Default is wom's default session
     */
    session?: Electron.Session;

    done?: (node: Webview) => void;
  }

  /**
   * 2d plane which can have any bitmap content as texture to render.
   * Canvas is subclass of Node. It adds 'canvas' type entity to Node base class and provides accessor and manipulator functions for a canvas as extension. 'canvas' type entities are either 2d planes in the 3d scene or overlay planes on native window. The rendered bitmap can be adjusted in Canvas. Webview is extending this class with the capability of rendering Chromium webview in Canvas's bitmap.
   */
  export interface Canvas extends Node {
    props: {
      /**
       *  The location of Canvas.
       */
      location: string;
      /**
       *  The resolution width of the Canvas's texture in pixels.
       */
      'resolution-width': number;
      /**
       *  The resolution height of the Canvas's texture in pixels.
       */
      'resolution-height': number;
      /**
       * Shows whether the Canvas is transparent.
       */
      transparent: boolean;
      /**
       *  Z order of overlay type Canvas.
       */
      zOrder: number;
      /**
       *  Determines the metrics used for left and top for overlay type Canvas.
       */
      metrics: 'pixels' | 'relative';
      /**
       * Determines how to align the overlay type Canvas horizontally.
       */
      'horizontal-align': 'left' | 'center' | 'right';
      /**
       * Determines how to align the overlay type Canvas vertically.
       */
      'vertical-align': 'top' | 'center' | 'bottom';
    };

    /**
     * @returns Object {width, height} - The size of Canvas in Ogre units (in-game) or pixels (overlay)
     */
    getSize(): { width: number; height: number };
    /**
     * Sets the size of Canvas
     * @param width Number - The width of Canvas in Ogre units (in-game) or pixels (overlay) to set.
     * @param height Number - The height of Canvas in Ogre units (in-game) or pixels (overlay) to set.
     */
    setSize(width: number, height: number): this;
    /**
     * Sets the resolution of Canvas's texture.
     * @param width Number - The resolution width of the Canvas's texture in pixels (Integer) to set.
     * @param height Number - The resolution height of the Canvas's texture in pixels (Integer) to set.
     */
    setResolution(width: number, height: number): this;
    /**
     * @returns Object {top, left} - The offset of left upper corner of overlay type Canvas from the display position origin (depends on alignment).
     *
     * Only for overlay type Canvas
     */
    getOffset(): { top: number; left: number };
    /**
     * Move the left upper corner of overlay type Canvas on the display. Unit depends on metrics and position origin depends on alignments.
     * @param left Number - Left position of Canvas
     * @param top Number - Top position of Canvas
     *
     * Applied only for overlay type Canvas
     */
    setOffset(left: number, top: number): this;
    /**
     * Sets the Z order of overlay type Canvas.
     * @param order Number - Z order to set (Integer).
     *
     * Applied only for overlay type Canvas
     */
    setZOrder(order: number): this;
    /**
     * Sets the location type of Canvas. Moves Canvas between display overlay and 3d scene
     * @param location String - Location type to set. Possible values are in-game, overlay.
     */
    setLocation(location: 'in-game' | 'overlay'): this;
    /**
     * Loads the specified picture into texture of Canvas. Transparent images should use premultiplied aplha channel
     * @param path String - Path to image file to render.
     */
    loadPicture(path: string): this;
    /**
     * Sets the overlay type Canvas passive or active. Passive overlay is not participating in mouse ray query, thus doesn't recieve mouse inputs. Therefore, 3d scene behind a passive overlay can interact with mouse, which is not possible otherwise.
     * @param passive Boolean - Enable passive mode
     *
     * Applied only for overlay type Canvas
     */

    setPassive(passive: boolean): this;
    /**
     * Sets the bitmap buffer of the underlying texture of Canvas.
     * @param damageRect Object - The area where the buffer data should be set {x, y, width, height}.
     * @param buffer Object - Bitmap to apply. A node::Buffer holding 32 bit ARGB data.
     * @param bufferSize Object - The size of buffer in pixels {width, height}.
     *
     * Example of feeding offscreen Electron webcontent into Canvas
     */
    setBuffer(
      damageRect: { x: number; y: number; width: number; height: number },
      buffer: Buffer,
      bufferSize: { width: number; height: number },
    ): this;
    /**
     * @returns whether any filtering is applied on the Ogre texture
     */
    isTextureFiltered(): boolean;
    /**
     * Sets texture filtering of Ogre texture. It's enabled by default.
     * Texture filtering can smoothen sharp edges in 3d scene, while disabling it can result crispy look for pixel precise overlays
     */
    setTextureFiltering(enable: boolean): this;

    setActiveAreas(activeAreaArray: ActiveArea[]): this;

    getActiveAreas(): ActiveArea[];

    addActiveArea(activeArea: ActiveArea): this;

    removeActiveArea(activeArea: ActiveArea): this;

    //TODO listeners
    on(eventName: NodeCoreEventName, handler: Function): this;
    on(
      eventName: NodeMouseEventName,
      handler: (event: NodeMouseEventObject) => void,
    ): this;
    on(
      eventName: NodeMouseWheelEventName,
      handler: (event: NodeMouseWheelEventObject) => void,
    ): this;

    once(
      eventName: NodeMouseEventName,
      handler: (event: NodeMouseEventObject) => void,
    ): this;
    once(
      eventName: NodeMouseWheelEventName,
      handler: (event: NodeMouseWheelEventObject) => void,
    ): this;

    once(eventName: NodeCoreEventName, handler: Function): this;

    //TODO listeners

    on(eventName: 'canvas-new-size', handler: Function): this;
    once(eventName: 'canvas-new-size', handler: Function): this;

    /**
     * Unregisters an event listener for the specified event. Handler function should be identical to the one which used to register the listener. That is it's not enough to have the same function body they should be the same javascript object. Consequently equivalent lambdas are not accepted
     * @param eventName Event type descriptor
     * @param handler  Handler function taking event as argument where event is an Object containing different properties according to the event type.
     */
    removeListener(
      eventName: NodeEventName | 'canvas-new-size',
      handler: Function,
    ): this;
  }

  interface ActiveArea {
    x: number;
    y: number;
    w: number;
    h: number;
  }

  type CanvasOptions = ProtoExntends<NodeOptions, CanvasOptionsExt>;
  interface CanvasOptionsExt {
    /**
     * The location of Canvas. Can be rendered into the 3d scene (in-game) or on the overlay of native window (overlay) in front of every scene object. Possible values are: in-game (default), overlay.
     */
    location?: 'in-game' | 'overlay';
    /**
     * The width of Canvas in Ogre units (in-game) or pixels (overlay). Default is 1280.
     */
    width?: number;
    /**
     * The height of Canvas in Ogre units (in-game) or pixels (overlay). Default is 720.
     */
    height?: number;
    /**
     * The resolution width of the Canvas's texture in pixels (Integer). Default is 1280.
     */
    'resolution-width'?: number;
    /**
     * The resolution height of the Canvas's texture in pixels (Integer). Default is 720.
     */
    'resolution-height'?: number;
    /**
     * Whether the Canvas is transparent. Alpha channel of texture's pixel color is used for transparency values. Default is true.
     */
    transparent?: boolean;
    /**
     * Z order of overlay type Canvas (Integer). Overlay with greater Z order covers overlays with less Z order. Default is 1.
     */
    zorder?: number;

    /**
     * Determines the metrics used for left and top for overlay type Canvas. Possible values are pixels (default), relative
     */
    metrics?: 'pixels' | 'relative';
    /**
     * For overlay type, the offset from the left of the window. Default is 0.
     */
    left?: number;
    /**
     * For overlay type, the offset from the top of the window. Default is 0.
     */
    top?: number;
    /**
     *  Determines how to align the overlay type Canvas horizontally. left's 0 point depends on this alignment. Possible values are left (default), center, right.
     */
    'horizontal-align'?: 'left' | 'center' | 'right';
    /**
     * Determines how to align the overlay type Canvas vertically. top's 0 point depends on this alignment. Possible values are top (default), center, bottom
     */
    'vertical-align'?: 'top' | 'center' | 'bottom';
    /**
     *  Determines whether Canvas registers canvas type physical shape matching Canvas's dimensions when created. If true physical shape is not registered (always true for overlay). Default is false.
     */
    disableIngamePhysical?: boolean;

    done?: (node: Overlay) => void;
  }

  interface GetterOption {
    local: boolean;
  }

  interface NodeWrap {
    GetChildrenNodes(): NodeWrap[];
    GetDerivedOrientation(): Quaternion;
    GetDerivedPosition(): Vector3;
    GetDerivedScale(): Vector3;
    GetName(): string;
    GetOrientation(): Quaternion;
    GetParentNode(): NodeWrap;
    GetPosition(): Vector3;
    GetScale(): Vector3;
    GetVisible(): boolean;

    //TODO setters
  }

  /**
   * The base for every element in the wom hierarchy. Its children are also nodes.
   */
  export type Node = ProtoExntends<NodeJS.EventEmitter, NodeExt>;
  export interface NodeExt extends NodeJS.EventEmitter {
    /**
     * A String which is the unique ID of Node. It is randomly generated or user specified.
     */
    id: string;
    /**
     * A Function which is called when the Node is created successfully. Called right after 'created' event is emitted
     */
    done: Function;
    /**
     * A Boolean that indicates that the Node is attached to an other parent Node. It implicitly shows whether the Node is inserted into 3d scene.
     */
    attached: boolean;
    /**
     * A Boolean that indicates that the node is created successfully. Turns true right before 'created' event is emitted
     */
    created: boolean;
    /**
     * A Node that is the parent of this Node. null means Node has no parent.
     */
    parent: Node | null;
    /**
     * A Node[] array that is the children of the Node.
     */
    children: Array<Node>;
    /**
     * A Boolean that indicates that Node is currently animated.
     */
    animating: boolean;
    /**
     * A String[] array containing element classes of this Node.
     */
    classArray: Array<string>;

    node: NodeWrap;

    nodeName: string;
    /**
     * Creates and attaches this Node in the 3d scene based on instance properties. If the Node has valid physical shape mouse event listeners are registered automatically.
     */
    create(): this;
    /**
     * Creates the specified Nodes and attaches them to this Node instance. Calls create() on every provided Node
     * @param element Child(ren) to create and add to this Node instance. If any element have further children they are getting created and attached recursively.
     */
    render(element: Node | Array<Node> | Component | Component[]): this;
    /**
     * Attaches this Node instance to parent Node. For the first attach the Node is created in the 3d scene.
     * @param parent Parent to attach this Node instance to. If no parent is provided the instance is attached to wom (root Node)
     */
    attach(parent?: Node): this;
    /**
     * Adds the specified Nodes to this Node instance as children. This function doesn't insert child Nodes into the 3d scene!
     * @param element Children to add to this Node instance
     */
    add(element: Node | Array<Node>): this;
    /**
     * Adds the specified Nodes to this Node instance as children. This function doesn't insert child Nodes into the 3d scene!
     * @param element Children to add to this Node instance
     */
    appendChild(element: Node | Array<Node>): this;
    /**
     * Removes a child Node of this Node instance. The child will be removed from Node's hierarchy but no entity belongs to it will be removed from 3d scene! Removes and destroys children of child recursively.
     * @param element Child to remove from this Node instance
     */
    removeChild(element: Node): this;
    /**
     * Deletes this Node from the Node hierarchy and the 3d scene. Deletes every entities, listeners and applied for children, too.
     */
    clear(): this;
    /**
     * Returns Object - The current position of the Node in 3d scene. {x, y, z}
     * @param options if local is set to true, the local is position is given
     */
    getPosition(options?: GetterOption): Vector3;
    /**
     * Sets the position of the Node, where position in defined in the given space and applied in the given reference.
     * @param position Position to set
     * @param ref Reference of the adjustment.
     * @param spc Space the adjustment is applied in.
     */
    setPosition(
      x: number,
      y: number,
      z: number,
      ref?: Reference,
      spc?: Space,
    ): this;
    setPosition(position: Vector3, ref?: Reference, spc?: Space): this;
    setPosition(
      position: [number, number, number],
      ref?: Reference,
      spc?: Space,
    ): this;
    /**
      /**
       * Translates the position of Node with the given offset, defined in the given space.
       * @param position Position to set
       * @param spc Space the adjustment is applied in.
       */
    translate(x: number, y: number, z: number, spc?: Space): this;
    translate(position: Vector3, spc?: Space): this;
    translate(position: [number, number, number], spc?: Space): this;
    /**
     * Returns Object - The scale of the Node along every dimension. {x, y, z}
     * @param options if local is set to true, the local is position is given
     */
    getScale(options?: GetterOption): Vector3;
    /**
     * Sets the scale of Node along every dimension. Scale values are defined in the given space in the given reference.
     * @param scale scale to set
     * @param ref Reference of the adjustment.
     * @param spc Space the adjustment is applied in.
     */
    setScale(
      x: number,
      y: number,
      z: number,
      ref?: Reference,
      spc?: Space,
    ): this;
    setScale(scale: Vector3, ref?: Reference, spc?: Space): this;
    setScale(
      scale: [number, number, number],
      ref?: Reference,
      spc?: Space,
    ): this;
    /**
     * Magnifies the Node with the specified measures along every dimension. Measures are defined in specified space and 1.0 represents the original scale.
     * @param scale scale to magnify
     * @param spc Space the adjustment is applied in.
     */
    magnify(x: number, y: number, z: number, spc?: Space): this;
    magnify(scale: Vector3, spc?: Space): this;
    magnify(scale: [number, number, number], spc?: Space): this;
    /**
     * Returns Object - Current orientation of the Node in the 3d scene as Quaternion. {w, x, y, z}
     * @param options if local is set to true, the local is position is given
     */
    getOrientation(options?: GetterOption): Quaternion;
    /**
     * Sets the orientation of the Node, where orientation in defined in the given space and applied in the given reference.
     * @param ori Orientation to set
     * @param ref Reference of the adjustment.
     * @param spc Space the adjustment is applied in.
     */
    setOrientation(
      w: number,
      x: number,
      y: number,
      z: number,
      ref?: Reference,
      spc?: Space,
    ): void;
    setOrientation(
      ori: Quaternion | AngleAxis,
      ref?: Reference,
      spc?: Space,
    ): void;
    /**
     * Rotates the Node with the specified orientation in the given space.
     * @param ori orientation to rotate with
     * @param spc  Space the adjustment is applied in.
     */
    rotate(w: number, x: number, y: number, z: number, spc?: Space): this;
    rotate(ori: Quaternion | AngleAxis, spc?: Space): this;
    /**
     * Animates the Node by changing the specified attribute of its transformation. Animation will change the attribute according to the specified option parameters step by step.
     * @param attribute Transformation type. Possible values are position, scale, orientation. Matching values are Object {x, y, z} for position, scale and Object {w, x, y, z} or {angle, axis} for orientation
     * @param options Options determining the run of the animation.
     * @param complete Callback for completed animation. If repeat is true the animation will be completed only if stopped manually.
     */
    animate(
      attribute: 'position' | 'scale',
      options: {
        /**
         * Start values of the animated attribute for every step. If it's omitted it will animate from the actual value of the attribute. Otherwise the length of array should be equal to number of animation steps.
         */
        from?: Vector3 | Array<Vector3>;
        /**
         * End values of the animated attribute for every step. The length of array should be equal to number of animation steps.
         */
        to: Vector3 | Array<Vector3>;
        /**
         * Duration of every animation steps in seconds. If animating through multiple steps but only one duration is provided, it will be used for every step. Otherwise the length of array should be equal to number of animation steps.
         */
        duration: number | Array<number>;
        /**
         *  Repeat the animation for ever. Default is false.
         */
        repeat?: boolean;
        /**
         * Loop the animation for ever. Animation will be played, then played backwards and repeated (overrides repeat if given contradictory). Default is false.
         */
        loop?: boolean;
        /**
         * The cubic easing function of the animation which defines the curve of temporal run.
         */
        cubic?: Bezier | EasingFunction;
        /**
         * Reference of the attribute adjustment.
         */
        reference?: Reference;
        /**
         *  Space the attribute adjustment is applied in.
         */
        space?: Space;
      },
      complete?: Function,
    ): this;
    animate(
      attribute: 'orientation',
      options: {
        /**
         * Start values of the animated attribute for every step. If it's omitted it will animate from the actual value of the attribute. Otherwise the length of array should be equal to number of animation steps.
         */
        from?: Quaternion | AngleAxis | Array<Quaternion | AngleAxis>;
        /**
         * End values of the animated attribute for every step. The length of array should be equal to number of animation steps.
         */
        to: Quaternion | AngleAxis | Array<Quaternion | AngleAxis>;
        /**
         * Duration of every animation steps in seconds. If animating through multiple steps but only one duration is provided, it will be used for every step. Otherwise the length of array should be equal to number of animation steps.
         */
        duration: number | Array<number>;
        /**
         *  Repeat the animation for ever. Default is false.
         */
        repeat?: boolean;
        /**
         * Loop the animation for ever. Animation will be played, then played backwards and repeated (overrides repeat if given contradictory). Default is false.
         */
        loop?: boolean;
        /**
         * The cubic easing function of the animation which defines the curve of temporal run.
         */
        cubic?: Bezier | EasingFunction;
        /**
         * Reference of the attribute adjustment.
         */
        reference?: Reference;
        /**
         *  Space the attribute adjustment is applied in.
         */
        space?: Space;
      },
      complete?: Function,
    ): this;
    /**
     * Cancels an ongoing animation for the specified attribute.
     * @param attribute Transformation type.
     */
    deanimate(attribute: Transformation): this;
    /**
     * Shows the Node's entities in 3d scene.
     */
    show(): this;
    /**
     * Hides the Node's entities in 3d scene.
     */
    hide(): this;
    /**
     *  Is entities of this Node visible in 3d scene
     */
    isShown(): boolean;
    /**
     * Adds auto-generated physical shape to Node based on the axis aligned bounding box of Node's entity (if any is present).
     */
    autoPhysical(): this;

    /**
     * Adds custom physical shape to Node
     * @param physh Descriptor of custom physical shape to add.
     */
    addPhysicalShape(physh: PhysicalShape): this;

    /**
     * Removes the specified physical shape from Node.
     * @param physh Descriptor of physical shape to remove.
     */
    removePhysicalShape(physh: {
      /**
       *  Type of physical shape.
       */
      shape: Shape;
      /**
       * Index of physical shape. Every added physical shape is grouped by shape types and indexed by insertion order. Note, that the index of a given shape can be modified when an other shape of that kind is removed! (Integer)
       */
      index: number;
    }): this;
    /**
     * Removes every physical shape from Node.
     */
    removeAllPhysicalShape(): this;
    /**
     *@returns The type of physical entity of this Node. Possible values are static, dynamic, kinematic, ghost.
     */
    getPhysicalType(): LinkType;
    /**
     * Sets the type of physical entity of this Node
     * @param phyt The physical type to set. Possible values are static, dynamic, kinematic, ghost.
     */
    setPhysicalType(phyt: LinkType): this;
    /**
     * Showing whether the physical entity of this Node is pointable with mouse (that is, accepts ray cast).
     */
    getPointable(): boolean;
    /**
     * Sets whether the physical entity of this Node is pointable with mouse
     * @param raycast Accept ray cast
     */
    setPointable(raycast: boolean): this;
    /**
     * Showing whether the physical entity of this Node can collide with other physical objects in 3d scene.
     */
    getCanCollide(): boolean;
    /**
     * Sets whether the physical entity of this Node can collide with other physical objects in 3d scene.
     * @param collide  Enable collision
     */
    setCanCollide(collide: boolean): this;
    /**
     * @returns Coefficient values of the physical entity of this Node describing the dynamical behaviour of physical shapes.
     */
    getCoeffs(): Coeffs;
    /**
     * Sets coefficient values of the physical entity of this Node describing the dynamical behaviour of physical shapes.
     * @param coeff Coefficient descriptor
     */
    setCoeffs(coeff: Coeffs): this;
    /**
     * Adds element class of Node.
     * @param args Any number of class to add
     */
    addClass(args: Array<string>): this;
    /**
     * Removes element class of Node.
     * @param args  Any number of class to remove
     */
    removeClass(args: Array<string>): this;
    /**
     *  Does this Node have specified element class
     * @param c Element class to query
     */
    hasClass(c: string): boolean;
    /**
     * Adds or removes element class of Node depending on provided condition.
     * @param c Element class to toggle
     * @param cond Condition which decide whether the element class should be added or removed. If not provided the class will be added if Node doesn't has it yet, otherwise removed.
     */
    toggleClass(c: string, cond?: boolean): this;
    /**
     * CCS style selector for Nodes. Element ID is Node's id and element classes are user defined. Returns Object - The first match of selector, or null if there was no match.
     * @param q Selector
     */
    select(q: string): BuiltInTypes;
    /**
     * CCS style selector for Nodes. Element ID is Node's id and element classes are user defined. Returns Object[] - Every match of selector, or [] if there was no match.
     * @param q Selector
     */
    selectAll(q: string): BuiltInTypes[];

    on(eventName: NodeCoreEventName, handler: Function): this;
    on(
      eventName: NodeMouseEventName,
      handler: (event: NodeMouseEventObject) => void,
    ): this;
    on(
      eventName: NodeMouseWheelEventName,
      handler: (event: NodeMouseWheelEventObject) => void,
    ): this;

    once(
      eventName: NodeMouseEventName,
      handler: (event: NodeMouseEventObject) => void,
    ): this;
    once(
      eventName: NodeMouseWheelEventName,
      handler: (event: NodeMouseWheelEventObject) => void,
    ): this;

    once(eventName: NodeCoreEventName, handler: Function): this;

    /**
     * Unregisters an event listener for the specified event. Handler function should be identical to the one which used to register the listener. That is it's not enough to have the same function body they should be the same javascript object. Consequently equivalent lambdas are not accepted
     * @param eventName Event type descriptor
     * @param handler  Handler function taking event as argument where event is an Object containing different properties according to the event type.
     */
    removeListener(eventName: NodeEventName, handler: Function): this;
  }
  type Animate = AnimatePosScale | AnimateOri;
  type AnimatePosScale = (
    attribute: 'position' | 'scale',
    options: {
      /**
       * Start values of the animated attribute for every step. If it's omitted it will animate from the actual value of the attribute. Otherwise the length of array should be equal to number of animation steps.
       */
      from?: Vector3 | Array<Vector3>;
      /**
       * End values of the animated attribute for every step. The length of array should be equal to number of animation steps.
       */
      to: Vector3 | Array<Vector3>;
      /**
       * Duration of every animation steps in seconds. If animating through multiple steps but only one duration is provided, it will be used for every step. Otherwise the length of array should be equal to number of animation steps.
       */
      duration: number | Array<number>;
      /**
       *  Repeat the animation for ever. Default is false.
       */
      repeat?: boolean;
      /**
       * Loop the animation for ever. Animation will be played, then played backwards and repeated (overrides repeat if given contradictory). Default is false.
       */
      loop?: boolean;
      /**
       * The cubic easing function of the animation which defines the curve of temporal run.
       */
      cubic?: Bezier | EasingFunction;
      /**
       * Reference of the attribute adjustment.
       */
      reference?: Reference;
      /**
       *  Space the attribute adjustment is applied in.
       */
      space?: Space;
    },
    complete?: Function,
  ) => Promise<void>;

  type AnimateOri = (
    attribute: 'orientation',
    options: {
      /**
       * Start values of the animated attribute for every step. If it's omitted it will animate from the actual value of the attribute. Otherwise the length of array should be equal to number of animation steps.
       */
      from?: Quaternion | AngleAxis | Array<Quaternion | AngleAxis>;
      /**
       * End values of the animated attribute for every step. The length of array should be equal to number of animation steps.
       */
      to: Quaternion | AngleAxis | Array<Quaternion | AngleAxis>;
      /**
       * Duration of every animation steps in seconds. If animating through multiple steps but only one duration is provided, it will be used for every step. Otherwise the length of array should be equal to number of animation steps.
       */
      duration: number | Array<number>;
      /**
       *  Repeat the animation for ever. Default is false.
       */
      repeat?: boolean;
      /**
       * Loop the animation for ever. Animation will be played, then played backwards and repeated (overrides repeat if given contradictory). Default is false.
       */
      loop?: boolean;
      /**
       * The cubic easing function of the animation which defines the curve of temporal run.
       */
      cubic?: Bezier | EasingFunction;
      /**
       * Reference of the attribute adjustment.
       */
      reference?: Reference;
      /**
       *  Space the attribute adjustment is applied in.
       */
      space?: Space;
    },
    complete?: Function,
  ) => Promise<void>;

  type NodeEventName =
    | NodeCoreEventName
    | NodeMouseEventName
    | NodeMouseWheelEventName;

  /**
   * Wheel mosue event object
   */
  interface NodeMouseWheelEventObject extends NodeMouseEventObject {
    /**
     * Delta wheel movement. y coordinate defines the ordinary wheel direction
     */
    delta: Vector3;
    /**
     * Delta mode (0: pixel 1: line 2: page)
     */
    deltamode: 0 | 1 | 2;
  }

  /**
   * Core mouse event object
   */
  interface NodeMouseEventObject {
    /**
     * Name of mouse event target physical object in 3d scene. (hovered object)
     */
    target: string;
    /**
     * Mouse event type.
     */
    type: string;
    /**
     * Triggering mouse button of the event. Possible values: left, right, middle, none, browser-back, browser-forward.
     */
    button:
      | 'left'
      | 'right'
      | 'middle'
      | 'none'
      | 'browser-back'
      | 'browser-forward';
    /**
     * Number - Bitmask of button states. Binary digits of buttons are: left:0, middle:1, right:2. (e.g. holding right and left button results 5 - 2^0 + 2^2)
     */
    buttonbitmask: number;
    /**
     * Is pointed object 3D object.
     */
    is3d: boolean;
    /**
     *  Is pointed object overlay.
     */
    isOverlay: boolean;
    /**
     * Is Ctrl key pressed.
     */
    ctrlKey: boolean;
    /**
     *  Is Shift key pressed.
     */
    shiftKey: boolean;
    /**
     * Is Alt key pressed.
     */
    altKey: boolean;
    /**
     * Is Meta key pressed (a.k.a. gui key, command on macOS, win key on Windows).
     */
    metaKey: boolean;
    /**
     * Screen position of cursor proportional to screen size as percentage.
     */
    screenPosProportional: Vector2;
    /**
     * Screen position of cursor in pixels.
     */
    screenPosPixels: Vector2;
    /**
     * Delta mouse movement proportional to screen size as percentage.
     */
    deltaPosProportional: Vector2;
    /**
     *  Delta mouse movement in pixels.
     */
    deltaPosPixels: Vector2;
    /**
     * 3D position of the cursor. Intersection coordinates between the pointed 3D object's physical hitshape and mouse ray originating from cursor's screen coordinate and pointing into 3D scene (-Z direction). Position is defined in scene's world coordinates.
     */
    spacePos: Vector3;
    /**
     * Normal of pointed 3D object.
     */
    spaceNormal: Vector3;
    /**
     * Position projected to area of a canvas (or any derived) type 3D object proportional to canvas size as percentage.
     */
    relativePosProportional: Vector3;
    /**
     * Position projected to area of a canvas (or any derived) type 3D object in pixels.
     */
    relativePosPixels: Vector2;
    /**
     * Custom attribute. For click event it holds number of consecutive clicks.
     */
    detail: number;
    /**
     * Duration between mouse press and release events for click type events in milliseconds
     */
    duration: number;
    /**
     *
     */
    cancelable: boolean;
    /**
     *
     */
    bubbles: boolean;
    /**
     * Timestamp of event in milliseconds. Defines when the event arrives in maxwhere engine's event loop.
     */
    timestamp: number;
  }
  type NodeMouseEventName =
    | 'click'
    | 'contextMenu'
    | 'dblclick'
    | 'mouseDown'
    | 'mouseUp'
    | 'mouseEnter'
    | 'mouseLeave'
    | 'mouseMove';
  type NodeMouseWheelEventName = 'mouseWheel';
  type NodeCoreEventName =
    | 'created'
    | 'deleted'
    | 'updated'
    | 'class-add'
    | 'class-remove';
  type BuiltInTypes =
    | Node
    | Mesh
    | Label
    | Canvas
    | Overlay
    | Webview
    | Light
    | ManualVisual
    | Webtable
    | Billboard
    | Component;

  interface Coeffs {
    /**
     * Linear damping. In range [0,1]. Default is 0.1
     */
    restitution?: number;
    /**
     *  Linear damping. In range [0,1]. Default is 0.1
     */
    'linear-damping'?: number;
    /**
     * Angular damping. In range [0,1]. Default is 0.1
     */
    'angular-damping'?: number;
    /**
     * Physical friction. In range [0,1]. Default is 0.3
     */
    friction?: number;
    /**
     * Rolling friction. In range [0,1]. Default is 0.01
     */
    'rolling-friction'?: number;
    /**
     * Gravity affecting physical entity in [m/s^2]. {x, y, z}. Default is {x: 0, y: -9.81, z: 0}
     */
    gravity?: Vector3;
  }

  export type Vector3 = {
    x: number;

    y: number;

    z: number;
  };

  export type Quaternion = {
    w: number;
    x: number;
    y: number;
    z: number;
  };
  export type AngleAxis = {
    axis:
      | {
          x: number;
          y: number;
          z: number;
        }
      | [number, number, number];
    angle: number;
  };

  type Reference = 'absolute' | 'relative';
  type Space = 'local' | 'parent' | 'world';
  type Transformation = 'position' | 'scale' | 'orientation';

  type LinkType = 'static' | 'dynamic' | 'kinematic' | 'ghost';

  type Bezier =
    | [x1: number, y1: number, x2: number, y2: number]
    | [{ x: number; y: number }, { x: number; y: number }];

  type Shape = 'box' | 'sphere' | 'mesh' | 'cylinder' | 'capsule' | 'canvas';
  type EasingFunction =
    | 'linear'
    | 'ease'
    | 'ease-in'
    | 'ease-out'
    | 'ease-in-out'
    | 'ease-in-out-back'
    | 'ease-in-out-circ'
    | 'ease-in-out-expo'
    | 'ease-in-out-sine'
    | 'ease-in-out-quint'
    | 'ease-in-out-quart'
    | 'ease-in-out-cubic'
    | 'ease-in-out-quad'
    | 'ease-out-back'
    | 'ease-out-circ'
    | 'ease-out-expo'
    | 'ease-out-sine'
    | 'ease-out-quint'
    | 'ease-out-quart'
    | 'ease-out-cubic'
    | 'ease-out-quad'
    | 'ease-in-back'
    | 'ease-in-circ'
    | 'ease-in-expo'
    | 'ease-in-sine'
    | 'ease-in-quint'
    | 'ease-in-quart'
    | 'ease-in-cubic'
    | 'ease-in-quad';

  interface PhysicalShape {
    /**
     * Name of shape type.
     */
    shape?: Shape;
    /**
     * Mass of shape. Default is 1.0
     */
    mass?: number;
    /**
     * Center of Gravity's offset according to Node's transformation. {x, y, z}. Default is {x: 0, y: 0, z: 0} (centered)
     */
    offset?: Vector3;
    /**
     * Center of Gravity's rotation according to Node's transformation. {w, x, y, z} or {angle: Number, axis: {x, y, z}}. Default is {w: 1, x: 0, y: 0, z: 0} (identical) Not applied for 'sphere' type
     */
    rotation?: Quaternion;
    /**
     * Width of the shape. Default is 10.0. Applied for box, canvas types
     */
    width?: number;
    /**
     * Height of the shape. Default is 10.0. Applied for box, cylinder, capsule, canvas types
     */
    height?: number;
    /**
     * Depth of the shape. Default is 10.0. Applied only for box type
     */
    depth?: number;
    /**
     * Radius of the shape. Default is 10.0. Applied for cylinder, sphere, capsule types
     */
    radius?: number;
    /**
     * Path to OBJ descriptor of shape. Applied only for mesh type
     */
    mesh?: string;
  }

  type ProtoExntends<T, U> = U & Omit<T, keyof U>;
}

declare namespace JSX {
  type Element = MaxWhere.BuiltInTypes;
  interface IntrinsicElements {
    node: MaxWhere.NodeOptions;
    mesh: MaxWhere.MeshOptions;
    label: MaxWhere.LabelOptions;
    canvas: MaxWhere.CanvasOptions;
    overlay: MaxWhere.OverlayOptions;
    webview: MaxWhere.WebviewOptions;
    light: MaxWhere.LightOptions;
    manualvisual: MaxWhere.ManualVisualOptions;
    webtable: MaxWhere.WebtableOptions;
    billboard: MaxWhere.BillBoardOptions;
    instancedmesh: MaxWhere.InstancedMeshOptions;
  }
}
