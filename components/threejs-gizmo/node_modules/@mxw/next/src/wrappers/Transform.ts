import * as THREE from '@mxw/three';
import {
  AngleAxis,
  Bezier,
  EasingFunction,
  Node,
  Quaternion,
  Reference,
  Space,
  Vector3,
  wom,
} from 'maxwhere';
import U3 from '@mxw/three-utils';
import _ from 'lodash';

// Unity Transform class and Three.js Object3D inspired MaxWhere Transform class.
// Unity Transform: https://docs.unity3d.com/ScriptReference/Transform.html
// Three.js Object3D https://threejs.org/docs/#api/en/core/Object3D.matrix

export default class Transform {
  node: Node;
  forwardIdentity: THREE.Vector3;
  upIdentity: THREE.Vector3;
  rightIdentity: THREE.Vector3;
  constructor(
    node: Node,
    forwardIdentity?: THREE.Vector3,
    upIdentity?: THREE.Vector3,
    rightIdentity?: THREE.Vector3,
  ) {
    this.node = node;
    this.forwardIdentity =
      forwardIdentity?.normalize() || new THREE.Vector3(0, 0, 1);
    this.upIdentity = upIdentity?.normalize() || new THREE.Vector3(0, 1, 0);
    this.rightIdentity =
      rightIdentity?.normalize() || new THREE.Vector3(1, 0, 0);
  }

  /**
   * World position of object
   */
  get position() {
    return U3.V3ToThree(this.node.getPosition());
  }
  set position(value: THREE.Vector3) {
    this.node.setPosition(U3.V3ToMw(value), 'absolute', 'world');
  }

  /**
   * Local position of object
   */
  get localPosition() {
    return U3.V3ToThree(this.node.getPosition({ local: true }));
  }
  set localPosition(value: THREE.Vector3) {
    this.node.setPosition(U3.V3ToMw(value));
  }

  /**
   * World rotation in quaternion.
   */
  get rotation() {
    return U3.QuatToThree(this.node.getOrientation());
  }

  set rotation(value: THREE.Quaternion) {
    this.node.setOrientation(
      U3.QuatToMw(value.normalize()),
      'absolute',
      'world',
    );
  }

  /**
   * Local rotation in quaternion
   */
  get localRotation() {
    return U3.QuatToThree(this.node.getOrientation({ local: true }));
  }

  set localRotation(value: THREE.Quaternion) {
    this.node.setOrientation(U3.QuatToMw(value.normalize()));
  }

  /**
   * World scale
   */
  get scale() {
    return U3.V3ToThree(this.node.getScale());
  }

  set scale(value: THREE.Vector3) {
    this.node.setScale(U3.V3ToMw(value), 'absolute', 'world');
  }

  /**
   * Local scale
   */
  get localScale() {
    return U3.V3ToThree(this.node.getScale({ local: true }));
  }

  set localScale(value: THREE.Vector3) {
    this.node.setScale(U3.V3ToMw(value));
  }

  /**
   * World matrix
   */
  get matrix() {
    return new THREE.Matrix4().compose(
      this.position,
      this.rotation,
      this.scale,
    );
  }

  /**
   * Local matrix
   */
  get localMatrix() {
    return new THREE.Matrix4().compose(
      this.localPosition,
      this.localRotation,
      this.localScale,
    );
  }

  /**
   * Returns a normalized vector representing the blue axis of the transform in world space.
   */
  get forward() {
    return new THREE.Vector3()
      .copy(this.forwardIdentity)
      .applyQuaternion(U3.QuatToThree(this.node.getOrientation()));
  }
  set forward(value: THREE.Vector3) {
    //TODO
    //maybe up vector is needed
    this.node.setOrientation(
      U3.QuatToMw(
        new THREE.Quaternion().setFromUnitVectors(this.forwardIdentity, value),
      ),
    );
  }

  /**
   * The green axis of the transform in world space.
   */
  get up() {
    return new THREE.Vector3()
      .copy(this.upIdentity)
      .applyQuaternion(U3.QuatToThree(this.node.getOrientation()));
  }

  set up(value: THREE.Vector3) {
    //maybe forward vector is needed
    this.node.setOrientation(
      U3.QuatToMw(
        new THREE.Quaternion().setFromUnitVectors(this.upIdentity, value),
      ),
    );
  }

  /**
   * The red axis of the transform in world space.
   */
  get right() {
    return new THREE.Vector3()
      .copy(this.rightIdentity)
      .applyQuaternion(U3.QuatToThree(this.node.getOrientation()));
  }

  set right(value: THREE.Vector3) {
    //maybe forward vector is needed
    this.node.setOrientation(
      U3.QuatToMw(
        new THREE.Quaternion().setFromUnitVectors(this.rightIdentity, value),
      ),
    );
  }

  /**
   * The rotation as Euler angles in radians.
   */
  get eulerAngles() {
    return new THREE.Euler().setFromQuaternion(
      U3.QuatToThree(this.node.getOrientation()),
      'ZXY',
    );
  }

  set eulerAngles(value: THREE.Euler) {
    let quat = U3.QuatToMw(new THREE.Quaternion().setFromEuler(value));
    this.node.setOrientation(quat, 'absolute', 'world');
  }

  /**
   * The rotation as Euler angles in degrees.
   */
  get eulerAnglesInDegrees() {
    let euler = new THREE.Euler().setFromQuaternion(
      U3.QuatToThree(this.node.getOrientation()),
      'ZXY',
    );
    return {
      x: euler.x * THREE.MathUtils.RAD2DEG,
      y: euler.y * THREE.MathUtils.RAD2DEG,
      z: euler.z * THREE.MathUtils.RAD2DEG,
    };
  }

  /**
   * The rotation as Euler angles in radians relative to the parent transform's rotation.
   */
  get localEulerAngles() {
    return new THREE.Euler().setFromQuaternion(
      U3.QuatToThree(this.node.getOrientation({ local: true })),
      'ZXY',
    );
  }

  set localEulerAngles(value: THREE.Euler) {
    let quat = U3.QuatToMw(new THREE.Quaternion().setFromEuler(value));
    this.node.setOrientation(quat);
  }

  /**
   * The rotation as Euler angles in degrees relative to the parent transform's rotation.
   */
  get localEulerAnglesInDegrees() {
    let euler = new THREE.Euler().setFromQuaternion(
      U3.QuatToThree(this.node.getOrientation({ local: true })),
      'ZXY',
    );
    return {
      x: euler.x * THREE.MathUtils.RAD2DEG,
      y: euler.y * THREE.MathUtils.RAD2DEG,
      z: euler.z * THREE.MathUtils.RAD2DEG,
    };
  }

  /**
   * Return children transforms
   * Warning! Forward, up and right vectors will be default and might give incorrect result.
   */
  get children() {
    return this.node.children.map((child) => new Transform(child));
  }

  /**
   * Converts the vector from this object's local space to world space.
   *
   * @param pos A vector representing a position in this object's local space.
   * @returns The new converted vector
   */
  localToWorld(pos: THREE.Vector3) {
    return pos.clone().applyMatrix4(this.matrix);
  }

  /**
   * Converts the vector from world space to this object's local space.
   *
   * @param pos A vector representing a position in world space.
   * @returns The new converted vector
   */
  worldToLocal(pos: THREE.Vector3) {
    return pos.clone().applyMatrix4(this.matrix.invert());
  }

  /**
   * Converts the vector from this object's local space to another local space.
   *
   * @param pos A vector representing a position in this object's local space.
   * @param transform The other object which local space we want to use.
   * @returns The new converted vector
   */
  localToLocal(pos: THREE.Vector3, transform: Transform) {
    return transform.worldToLocal(this.localToWorld(pos));
  }

  /**
   * Rotates the transform so the forward vector points at /target/'s current positions's X and Z cooridinates.
   * @param pos position too look at
   */
  lookAtXZ(pos: THREE.Vector3) {
    let posXZ = pos.clone();
    posXZ.setY(this.position.y);
    this.lookAt(posXZ);
  }

  /**
   * Rotates the transform so the forward vector points at /target/'s current position.
   * @param pos position too look at
   */
  lookAt(pos: THREE.Vector3) {
    let rotationMatrix = new THREE.Matrix4().lookAt(
      this.position,
      pos,
      this.upIdentity,
    );

    this.node.setOrientation(
      U3.QuatToMw(
        new THREE.Quaternion()
          .setFromRotationMatrix(rotationMatrix)
          .multiply(
            new THREE.Quaternion().setFromUnitVectors(
              new THREE.Vector3(0, 0, -1),
              this.forwardIdentity,
            ),
          ),
      ),
      'absolute',
      'world',
    );
  }

  /**
   * Look at position and animate it.
   * @param pos position to look at
   * @param duration duration in sec
   * @param overrideCurrentPos overrides this.position during calculation
   */
  async lookAtAnimate(
    pos: THREE.Vector3,
    duration: number,
    overrideCurrentPos?: THREE.Vector3,
  ) {
    let rotationMatrix: THREE.Matrix4;
    if (overrideCurrentPos) {
      rotationMatrix = new THREE.Matrix4().lookAt(
        overrideCurrentPos,
        pos,
        this.upIdentity,
      );
    } else {
      rotationMatrix = new THREE.Matrix4().lookAt(
        this.position,
        pos,
        this.upIdentity,
      );
    }

    await this.animate('orientation', {
      to: U3.QuatToMw(
        new THREE.Quaternion()
          .setFromRotationMatrix(rotationMatrix)
          .multiply(
            new THREE.Quaternion().setFromUnitVectors(
              new THREE.Vector3(0, 0, -1),
              this.forwardIdentity,
            ),
          ),
      ),
      duration: duration,
    });
  }
  /**
   * Look at direction.
   * @param dir Direction vector.
   */
  lookAtDir(dir: THREE.Vector3) {
    let rotationMatrix = new THREE.Matrix4().lookAt(
      dir,
      new THREE.Vector3(0, 0, 0),
      this.upIdentity,
    );

    this.node.setOrientation(
      U3.QuatToMw(
        new THREE.Quaternion()
          .setFromRotationMatrix(rotationMatrix)
          .multiply(
            new THREE.Quaternion().setFromUnitVectors(
              new THREE.Vector3(0, 0, -1),
              this.forwardIdentity,
            ),
          ),
      ),
    );
  }

  /**
   * Promise wrapper for Maxwhere Node.animate
   * Animates the Node by changing the specified attribute of its transformation. Animation will change the attribute according to the specified option parameters step by step.
   *
   * @param attribute Transformation type. Possible values are position, scale, orientation. Matching values are Object {x, y, z} for position, scale and Object {w, x, y, z} or {angle, axis} for orientation
   * @param options Options determining the run of the animation.
   * @param complete Callback for completed animation. If repeat is true the animation will be completed only if stopped manually.
   * @returns Promise which resolves when animation is completed
   */
  animate(
    attribute: 'orientation' | 'position' | 'scale',
    options: {
      /**
       * Start values of the animated attribute for every step. If it's omitted it will animate from the actual value of the attribute. Otherwise the length of array should be equal to number of animation steps.
       */
      from?:
        | Quaternion
        | AngleAxis
        | Array<Quaternion | AngleAxis>
        | Vector3
        | Array<Vector3>;
      /**
       * End values of the animated attribute for every step. The length of array should be equal to number of animation steps.
       */
      to:
        | Quaternion
        | AngleAxis
        | Array<Quaternion | AngleAxis>
        | Vector3
        | Array<Vector3>;
      /**
       * Duration of every animation steps in seconds. If animating through multiple steps but only one duration is provided, it will be used for every step. Otherwise the length of array should be equal to number of animation steps.
       */
      duration: number | Array<number>;
      /**
       *  Repeat the animation for ever. Default is false.
       */
      repeat?: boolean;
      /**
       * Loop the animation for ever. Animation will be played, then played backwards and repeated (overrides repeat if given contradictory). Default is false.
       */
      loop?: boolean;
      /**
       * The cubic easing function of the animation which defines the curve of temporal run.
       */
      cubic?: Bezier | EasingFunction;
      /**
       * Reference of the attribute adjustment.
       */
      reference?: Reference;
      /**
       *  Space the attribute adjustment is applied in.
       */
      space?: Space;
    },
    complete?: Function,
  ) {
    return new Promise((resolve) => {
      //@ts-ignore
      this.node.animate(attribute, options, () => {
        if (complete) {
          complete();
        }
        resolve(this.node);
      });
    });
  }

  /**
   * Look at this with maxwhere camera.
   * @param duration animation duration in sec
   * @param offset position offset for camera compared to this.position. If offset is an array the closest position to the current camera position will be chosen.
   */
  async lookAtThisWithCamera(
    duration: number,
    offset: THREE.Vector3 | THREE.Vector3[],
  ) {
    let cameraTargetPosition: THREE.Vector3;
    let camera = new Transform(wom.camera, new THREE.Vector3(0, 0, -1));
    if (_.isArray(offset)) {
      let minDistance = Infinity;
      for (let index = 0; index < offset.length; index++) {
        let posCandidate = this.position.add(offset[index]);
        let distance = posCandidate.distanceTo(camera.position);
        if (distance < minDistance) {
          minDistance = distance;
          cameraTargetPosition = posCandidate;
        }
      }
    } else {
      cameraTargetPosition = this.position.add(offset);
    }

    await Promise.all([
      camera.animate('position', {
        to: U3.V3ToMw(cameraTargetPosition!),
        duration: duration,
      }),
      camera.lookAtAnimate(this.position, duration / 2, cameraTargetPosition!),
    ]);
  }

  /**
   * Rotate an object along an axis in object space. The axis is assumed to be normalized.
   * @param axis A normalized vector in object space.
   * @param angle The angle in degrees.
   * @returns
   */
  rotateOnAxis(axis: THREE.Vector3, angle: number) {
    // rotate object on axis in object space
    // axis is assumed to be normalized

    let offsetRotation = new THREE.Quaternion().setFromAxisAngle(
      axis,
      angle * THREE.MathUtils.DEG2RAD,
    );

    this.localRotation = this.localRotation.multiply(offsetRotation);

    return this;
  }

  /**
   *  Rotate an object along an axis in world space. The axis is assumed to be normalized.
   * @param axis A normalized vector in object space.
   * @param angle The angle in degrees.
   * @returns
   */
  rotateOnWorldAxis(axis: THREE.Vector3, angle: number) {
    // rotate object on axis in world space
    // axis is assumed to be normalized

    let offsetRotation = new THREE.Quaternion().setFromAxisAngle(
      axis,
      angle * THREE.MathUtils.DEG2RAD,
    );

    this.rotation = this.rotation.multiply(offsetRotation);

    return this;
  }
}
