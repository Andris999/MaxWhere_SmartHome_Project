import {
  Material,
  Mesh,
  Node,
  ShaderTypeNumber,
  ShaderTypeString,
} from 'maxwhere';
import Transform from './Transform';
import * as THREE from '@mxw/three';

export default class MeshTransform extends Transform {
  mesh: Mesh;
  materialUniqueNess: boolean[];
  constructor(
    mesh: Mesh,
    forwardIdentity?: THREE.Vector3,
    upIdentity?: THREE.Vector3,
    rightIdentity?: THREE.Vector3,
  ) {
    super(mesh, forwardIdentity, upIdentity, rightIdentity);
    this.mesh = mesh;
    this.materialUniqueNess = [];
    let interval = setInterval(() => {
      if (this.mesh.created) {
        if (this.mesh.subvisuals) {
          this.mesh.subvisuals().forEach((subvisual) => {
            this.materialUniqueNess.push(false);
          });
          clearInterval(interval);
        }
      }
    }, 1000);
  }

  /**
   * Set material to transparent
   * @param transp
   * @param subvisualNumber
   * @param duration [milisec] changes back to the original state after duration elapsed, if not set, change is permanent
   * @returns
   */
  async setTransparent(
    transp: boolean,
    subvisualNumber: number = 0,
    duration?: number,
  ) {
    let material = this.getUniqueMaterial(subvisualNumber);

    material.setTransparentBlend(transp);

    if (duration != undefined) {
      setTimeout(() => {
        material.setTransparentBlend(!transp);
        return;
      }, duration);
    } else {
      return;
    }
  }

  /**
   * Set shader of material
   * @param shaderName
   * @param value
   * @param subvisualNumber
   * @param duration [milisec] changes back to the original state after duration elapsed, if not set, change is permanent
   */
  async setShader(
    shaderName: ShaderTypeNumber,
    value: number,
    subvisualNumber: number = 0,
    duration?: number,
  ) {
    let material = this.getUniqueMaterial(subvisualNumber);

    if (duration != undefined) {
      let originalValue = material.shaderValue(shaderName);
      setTimeout(() => {
        material.setShader(shaderName, originalValue);
      }, duration);
    }

    material.setShader(shaderName, value);
  }

  private getUniqueMaterial(subvisualNumber: number = 0) {
    let material: Material;
    if (this.materialUniqueNess[subvisualNumber]) {
      material = this.mesh.material(this.mesh.subvisual(subvisualNumber));
    } else {
      this.materialUniqueNess[subvisualNumber] = true;
      material = this.createUniqueMaterial(subvisualNumber);
    }
    return material;
  }

  /**
   * Sets material to transparent, and turns off raycast
   * @param ghost
   * @param subvisualNumber
   * @param duration [milisec] changes back to the original state after duration elapsed, if not set, change is permanent
   * @returns
   */
  setGhostMode(ghost: boolean, subvisualNumber: number = 0, duration?: number) {
    this.setTransparent(ghost, subvisualNumber, duration);
    this.mesh.setPointable(!ghost);
    if (duration != undefined) {
      setTimeout(() => {
        this.mesh.setPointable(ghost);
        return;
      }, duration);
    } else {
      return;
    }
  }

  private createUniqueMaterial(number: number) {
    const mat = this.mesh.material(this.mesh.subvisual(number));
    const materialName = '_' + Math.random().toString(36).substr(2, 9); // random unique name for material
    const cloneMat = mat.clone(materialName);
    this.mesh.setMaterial(materialName, number);
    return cloneMat;
  }
}
