import {
  Color,
  ColorGeometry,
  PositionGeometry,
  Section,
  wom,
  PhysicalShape,
} from 'maxwhere';
import Transform from './Transform';
import * as THREE from '@mxw/three';
import _ from 'lodash';
import U3 from '@mxw/three-utils';
import { TextGeometry } from '../utils/TextGeometry';
import { Font } from '../utils/FontLoader';

abstract class GeometryBuilder {
  /**
   * Get faces of a geometry converted from a three.js BufferGeometry to a maxwhere manualvisual "section".
   *
   *  NOTE: color is only  affected if you use a special "vertex driven" material. For exmaple the built in "Physics/DebugDraw/VertexDriven" material.
   * @param geometry
   * @param material_name name of the material
   * @param color Normalized rgba color, number values are betwenn 0 and 1. Example: {r:1, g:0.5, b:0, a:1}. If "random" is set than every vertex gets a random color.
   * @returns Section
   */
  static getFacesFromGeometry(
    geometry: THREE.BufferGeometry,
    material_name: string,
    color?: Color | 'random',
  ): Section {
    //geometry.toNonIndexed();
    const positionAttribute = geometry.toNonIndexed().attributes.position;

    const vertex = new THREE.Vector3();

    let mwGeometry: (PositionGeometry | ColorGeometry)[] = [];

    if (color && color != 'random') {
      mwGeometry.push({
        type: 'color',
        arg: color,
      });
    }

    for (
      let vertexIndex = 0;
      vertexIndex < positionAttribute.count;
      vertexIndex += 3
    ) {
      if (color == 'random') {
        mwGeometry.push({
          type: 'color',
          arg: {
            r: Math.random(),
            g: Math.random(),
            b: Math.random(),
            a: Math.random(),
          },
        });
      }

      vertex.fromBufferAttribute(positionAttribute, vertexIndex);

      mwGeometry.push({
        type: 'position',
        arg: { x: vertex.x, y: vertex.y, z: vertex.z },
      });

      vertex.fromBufferAttribute(positionAttribute, vertexIndex + 1);

      mwGeometry.push({
        type: 'position',
        arg: { x: vertex.x, y: vertex.y, z: vertex.z },
      });

      vertex.fromBufferAttribute(positionAttribute, vertexIndex + 2);

      mwGeometry.push({
        type: 'position',
        arg: { x: vertex.x, y: vertex.y, z: vertex.z },
      });
    }

    let section: Section = {
      material_name: material_name,
      renderop: 'trianglelist',
      geometry: mwGeometry,
    };

    return section;
  }

  /**
   * Get wireframe of a geometry converted from a three.js BufferGeometry to a maxwhere manualvisual "section".
   *
   *  NOTE: color is only  affected if you use a special "vertex driven" material. For exmaple the built in "Physics/DebugDraw/VertexDriven" material.
   * @param geometry
   * @param material_name name of the material
   * @param color Normalized rgba color, number values are betwenn 0 and 1. Example: {r:1, g:0.5, b:0, a:1}. If "random" is set than every vertex gets a random color.
   * @returns Section
   */
  static getWireframeFromGeometry(
    geometry: THREE.BufferGeometry,
    material_name: string,
    color?: Color | 'random',
  ): Section {
    const wireframeGeometry = new THREE.WireframeGeometry(geometry);
    const positionAttribute = wireframeGeometry.attributes.position;

    const vertex = new THREE.Vector3();

    let mwGeometry: (PositionGeometry | ColorGeometry)[] = [];

    if (color && color != 'random') {
      mwGeometry.push({
        type: 'color',
        arg: color,
      });
    }

    for (
      let vertexIndex = 0;
      vertexIndex < positionAttribute.count;
      vertexIndex += 2
    ) {
      if (color == 'random') {
        mwGeometry.push({
          type: 'color',
          arg: {
            r: Math.random(),
            g: Math.random(),
            b: Math.random(),
            a: Math.random(),
          },
        });
      }
      vertex.fromBufferAttribute(positionAttribute, vertexIndex);

      mwGeometry.push({
        type: 'position',
        arg: { x: vertex.x, y: vertex.y, z: vertex.z },
      });

      vertex.fromBufferAttribute(positionAttribute, vertexIndex + 1);

      mwGeometry.push({
        type: 'position',
        arg: { x: vertex.x, y: vertex.y, z: vertex.z },
      });
    }

    let section: Section = {
      material_name: material_name,
      renderop: 'linelist',
      geometry: mwGeometry,
    };

    return section;
  }

  /**
   * Get edges of a geometry converted from a three.js BufferGeometry to a maxwhere manualvisual "section".
   *
   *  NOTE: color is only  affected if you use a special "vertex driven" material. For exmaple the built in "Physics/DebugDraw/VertexDriven" material.
   * @param geometry
   * @param material_name name of the material
   * @param color Normalized rgba color, number values are betwenn 0 and 1. Example: {r:1, g:0.5, b:0, a:1}. If "random" is set than every vertex gets a random color.
   * @returns Section
   */
  static getEdgesFromGeometry(
    geometry: THREE.BufferGeometry,
    material_name: string,
    color?: Color | 'random',
  ): Section {
    const wireframeGeometry = new THREE.EdgesGeometry(geometry, 5);
    const positionAttribute = wireframeGeometry.attributes.position;

    const vertex = new THREE.Vector3();

    let mwGeometry: (PositionGeometry | ColorGeometry)[] = [];

    if (color && color != 'random') {
      mwGeometry.push({
        type: 'color',
        arg: color,
      });
    }

    for (
      let vertexIndex = 0;
      vertexIndex < positionAttribute.count;
      vertexIndex += 2
    ) {
      if (color == 'random') {
        mwGeometry.push({
          type: 'color',
          arg: {
            r: Math.random(),
            g: Math.random(),
            b: Math.random(),
            a: Math.random(),
          },
        });
      }
      vertex.fromBufferAttribute(positionAttribute, vertexIndex);

      mwGeometry.push({
        type: 'position',
        arg: { x: vertex.x, y: vertex.y, z: vertex.z },
      });

      vertex.fromBufferAttribute(positionAttribute, vertexIndex + 1);

      mwGeometry.push({
        type: 'position',
        arg: { x: vertex.x, y: vertex.y, z: vertex.z },
      });
    }

    let section: Section = {
      material_name: material_name,
      renderop: 'linelist',
      geometry: mwGeometry,
    };

    return section;
  }

  static getLineSectionFromPoints(
    points: THREE.Vector3[],
    material_name: string,
    color?: Color | [Color, Color] | 'random',
  ): Section {
    let section: Section = {
      material_name: material_name,
      renderop: 'linestrip',
      geometry: [],
    };
    if (color) {
      if (_.isArray(color)) {
        let posGeometries = this.convertThreePointsToPosGeometryArray(points);

        posGeometries.forEach((posgeometry, index) => {
          section.geometry.push(
            {
              type: 'color',
              arg: {
                r:
                  ((color[1].r - color[0].r) / points.length) * index +
                  color[0].r,
                g:
                  ((color[1].g - color[0].g) / points.length) * index +
                  color[0].g,
                b:
                  ((color[1].b - color[0].b) / points.length) * index +
                  color[0].b,
                a:
                  ((color[1].a! - color[0].a!) / points.length) * index +
                  color[0].a!,
              },
            },
            posgeometry,
          );
        });
      } else if (color == 'random') {
        let posGeometries = this.convertThreePointsToPosGeometryArray(points);

        posGeometries.forEach((posgeometry) => {
          section.geometry.push(
            {
              type: 'color',
              arg: {
                r: Math.random(),
                g: Math.random(),
                b: Math.random(),
                a: 1,
              },
            },
            posgeometry,
          );
        });
      } else {
        section.geometry.push({
          type: 'color',
          arg: color,
        });

        section.geometry.push(
          ...this.convertThreePointsToPosGeometryArray(points),
        );
      }
    } else {
      section.geometry.push(
        ...this.convertThreePointsToPosGeometryArray(points),
      );
    }

    return section;
  }

  private static convertThreePointsToPosGeometryArray(
    points: THREE.Vector3[],
  ): PositionGeometry[] {
    return points.map((point) => {
      return {
        type: 'position',
        arg: U3.V3ToMw(point),
      };
    });
  }

  /**
   * Get bounding shape from a three.js geometry
   * @param geometry
   * @param type
   * @returns
   */
  static getPhysicalShapeFromGeometry(
    geometry: THREE.BufferGeometry,
    type: 'boundingbox' | 'boundingsphere',
  ): PhysicalShape {
    if (type == 'boundingbox') {
      geometry.computeBoundingBox();
      let bbox = geometry.boundingBox!;
      let center = U3.V3ToMw(bbox.getCenter(new THREE.Vector3()));
      let size = bbox.getSize(new THREE.Vector3());
      return {
        offset: center,
        width: size.x,
        height: size.y,
        depth: size.z,
        shape: 'box',
      };
    } else if (type == 'boundingsphere') {
      geometry.computeBoundingSphere();
      let bsphere = geometry.boundingSphere;
      let center = U3.V3ToMw(bsphere!.center);
      let radius = bsphere!.radius;
      return {
        offset: center,
        radius: radius,
        shape: 'sphere',
      };
    }

    return {};
  }

  /**
   * Build a three.js TextGeometry
   * @param text
   * @param parameters
   * @returns
   */
  static getTextGeometry(
    text: string,
    parameters: THREE.ExtrudeGeometryOptions & {
      fontJSON: object;
      size?: number;
      height?: number;
    },
  ) {
    let textGeometry: TextGeometry;
    if (parameters.fontJSON) {
      let font = { font: new Font(parameters.fontJSON) };
      textGeometry = new TextGeometry(text, Object.assign(parameters, font));
    } else {
      textGeometry = new TextGeometry(text, parameters);
    }

    return textGeometry;
  }
}

export default GeometryBuilder;
