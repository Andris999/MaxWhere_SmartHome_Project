//@ts-nocheck
import _CSG from './three-csg.js';
import * as THREE from '@mxw/three';

export default abstract class CSG {
  /**
   * Get union of two geometry
   * @param a_geometry
   * @param b_geometry
   * @returns
   */
  static union(
    a_geometry: THREE.BufferGeometry,
    b_geometry: THREE.BufferGeometry,
  ): THREE.BufferGeometry {
    let aCSG = _CSG.fromGeometry(a_geometry);
    let bCSG = _CSG.fromGeometry(b_geometry);

    let resultCSG = aCSG.union(bCSG);
    let resultGeometry = _CSG.toGeometry(resultCSG);

    return resultGeometry;
  }

  /**
   * Subtract b from a geometry
   * @param a_geometry
   * @param b_geometry
   * @returns
   */
  static subtract(
    a_geometry: THREE.BufferGeometry,
    b_geometry: THREE.BufferGeometry,
  ): THREE.BufferGeometry {
    let aCSG = _CSG.fromGeometry(a_geometry);
    let bCSG = _CSG.fromGeometry(b_geometry);

    let resultCSG = aCSG.subtract(bCSG);
    let resultGeometry = _CSG.toGeometry(resultCSG);

    return resultGeometry;
  }

  /**
   * Intersection of a and b geometry
   * @param a_geometry
   * @param b_geometry
   * @returns
   */
  static intersect(
    a_geometry: THREE.BufferGeometry,
    b_geometry: THREE.BufferGeometry,
  ): THREE.BufferGeometry {
    let aCSG = _CSG.fromGeometry(a_geometry);
    let bCSG = _CSG.fromGeometry(b_geometry);

    let resultCSG = aCSG.intersect(bCSG);
    let resultGeometry = _CSG.toGeometry(resultCSG);

    return resultGeometry;
  }

  /**
   * Invert geometry
   * @param a_geometry
   * @returns
   */
  static inverse(a_geometry: THREE.BufferGeometry): THREE.BufferGeometry {
    let aCSG = _CSG.fromGeometry(a_geometry);

    let resultCSG = aCSG.inverse();
    let resultGeometry = _CSG.toGeometry(resultCSG);

    return resultGeometry;
  }
}
