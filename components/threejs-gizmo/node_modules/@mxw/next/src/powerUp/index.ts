import womAsync from '../wrappers/womAsync.module';
import {
  wom,
  Vector3,
  Quaternion,
  Mesh,
  ManualVisual,
  Node,
  Section,
  ColorGeometry,
  Label,
  InstancedMesh,
} from 'maxwhere';
import U3 from '@mxw/three-utils';
import Transform from '../wrappers/Transform';
import Gizmo from '../gizmo/index';
import AxesHelper from '..//helper/axeshelper';
import GridHelper from '..//helper/gridHelper';
type NodeInfoConfig = { bbox: boolean; log: boolean };
let boundingBox: ManualVisual | null;
let section = geBoundingBoxSection();

/**
 * Power-up is a set of useful utilities to use during development.
 * Functionalities:
 *   - nodeInfo:  Ctrl + left click on a mesh will show it's bounding box and basic info is shown on a label and also logs to the F6 dev console
 *   - (camera)stepper: Animate camera movement between defined camera positions and orientations.
 *      - O - add step
 *      - L - step forward
 *      - K - step backwards
 *      - M - increase animation duration
 *      - N - decrease animation duration
 * @param config
 */
function init(config?: {
  stepper: boolean;
  nodeInfo: NodeInfoConfig;
  gizmo: boolean;
  axesHelper: boolean;
  gridHelper: boolean;
}) {
  if (config) {
    if (config.stepper) {
      stepper();
    }

    if (config.nodeInfo) {
      initNodeInfo(config.nodeInfo);
    }

    if (config.gizmo) {
      let gizmo = new Gizmo({
        snap: {
          isKeyActive: false,
        },
      });
      if (config.axesHelper) {
        let axesHelper = new AxesHelper(10000);
      }
      if (config.axesHelper) {
        let gridHelper = new GridHelper(10000, 100, true);
      }
    }
  } else {
    stepper();
    initNodeInfo({ bbox: true, log: true });
    let gizmo = new Gizmo({
      snap: {
        isKeyActive: false,
      },
    });
    let axesHelper = new AxesHelper(10000);
    let gridHelper = new GridHelper(10000, 100, true);
  }
}
function initNodeInfo(config: NodeInfoConfig) {
  womAsync.selfAwareListener(
    'click',
    (event) => {
      if (event.target.includes('_physical') && event.ctrlKey) {
        let id = event.target.replace('_physical', '');
        let target: Mesh = wom.select(`#${id}`) as Mesh;
        if (config.log) {
          womAsync.log(getNodeInfo(target));
        }
        if (config.bbox) {
          showBoundingBox(target);
        }
      }
    },
    wom,
  );
}

function showBoundingBox(target: Mesh) {
  if (boundingBox || !target) {
    boundingBox!.clear();
    boundingBox = null;
  }
  {
    boundingBox = wom.create('manualvisual', {
      //@ts-ignore
      position: target.entity.GetAABB().center,
      //@ts-ignore
      scale: target.entity.GetAABB().size,
      sections: [section],
    });

    let label = wom.create('label', {
      autorotate: true,
      caption: getNodeInfo(target),
      charheight: 0.24,
      color: { r: 0, g: 0, b: 0 },
      background: {
        enable: true,
        color: { r: 1, g: 1, b: 1 },
      },
      ontop: true,
    });
    boundingBox.add(label);
    //wom.render(boundingBox);
    target.render(boundingBox);
  }
}

function geBoundingBoxSection() {
  let points = [
    { x: -0.5, y: -0.5, z: 0.5 },
    { x: 0.5, y: -0.5, z: 0.5 },
    { x: 0.5, y: 0.5, z: 0.5 },
    { x: -0.5, y: 0.5, z: 0.5 },
    { x: -0.5, y: -0.5, z: -0.5 },
    { x: 0.5, y: -0.5, z: -0.5 },
    { x: 0.5, y: 0.5, z: -0.5 },
    { x: -0.5, y: 0.5, z: -0.5 },
  ];
  let color: ColorGeometry = {
    type: 'color',
    arg: { r: 1, g: 1, b: 0, a: 1 },
  };
  let section: Section = {
    renderop: 'linelist',
    material_name: 'Physics/DebugDraw/VertexDriven',
    geometry: [],
  };
  section.geometry.push(
    { type: 'position', arg: points[0] },
    color,
    { type: 'position', arg: points[1] },
    color,
  );
  section.geometry.push(
    { type: 'position', arg: points[1] },
    color,
    { type: 'position', arg: points[2] },
    color,
  );
  section.geometry.push(
    { type: 'position', arg: points[2] },
    color,
    { type: 'position', arg: points[3] },
    color,
  );
  section.geometry.push(
    { type: 'position', arg: points[3] },
    color,
    { type: 'position', arg: points[0] },
    color,
  );
  section.geometry.push(
    { type: 'position', arg: points[0] },
    color,
    { type: 'position', arg: points[4] },
    color,
  );
  section.geometry.push(
    { type: 'position', arg: points[1] },
    color,
    { type: 'position', arg: points[5] },
    color,
  );
  section.geometry.push(
    { type: 'position', arg: points[2] },
    color,
    { type: 'position', arg: points[6] },
    color,
  );
  section.geometry.push(
    { type: 'position', arg: points[3] },
    color,
    { type: 'position', arg: points[7] },
    color,
  );
  section.geometry.push(
    { type: 'position', arg: points[4] },
    color,
    { type: 'position', arg: points[5] },
    color,
  );
  section.geometry.push(
    { type: 'position', arg: points[5] },
    color,
    { type: 'position', arg: points[6] },
    color,
  );
  section.geometry.push(
    { type: 'position', arg: points[6] },
    color,
    { type: 'position', arg: points[7] },
    color,
  );
  section.geometry.push(
    { type: 'position', arg: points[7] },
    color,
    { type: 'position', arg: points[4] },
    color,
  );
  return section;
}

function getNodeInfo(target: Mesh | InstancedMesh) {
  let materials;

  if (target.nodeName == 'instancedmesh') {
    materials = 'cannot read materialis on instancedmesh';
  } else {
    materials = target
      .subvisuals()
      .map((subvisual) => subvisual.material.GetName());
  }
  let nodeInfo = {
    id: target.id,
    url: target.url,
    position: target.getPosition(),
    orientation: target.getOrientation(),
    scale: target.getScale(),
    materials: materials,
  };

  return JSON.stringify(nodeInfo, null, '\n');
}
function stepper() {
  let steps: {
    pos: Vector3;
    ori: Quaternion;
  }[] = [];
  let currentStep = 0;

  let duration = 7;
  womAsync.selfAwareListener(
    'input-keyboard',
    (e) => {
      if (e.type == 'keyDown') {
        switch (e.keyName) {
          case 'O':
            steps.push({
              pos: wom.camera.getPosition(),
              ori: wom.camera.getOrientation(),
            });
            womAsync.log(`Step ${steps.length - 1} added.`);

            break;

          case 'L':
            if (!wom.camera.animating) {
              if (currentStep == steps.length - 1) {
                currentStep = 0;
              } else {
                currentStep++;
              }
              wom.camera.animate('position', {
                to: steps[currentStep].pos,
                duration: duration,
              });

              wom.camera.animate('orientation', {
                to: steps[currentStep].ori,
                duration: duration,
              });
              womAsync.log(`Step ${currentStep} animating.`);
            }

            break;
          case 'K':
            if (!wom.camera.animating) {
              if (currentStep == 0) {
                currentStep = steps.length - 1;
              } else {
                currentStep--;
              }
              wom.camera.animate('position', {
                to: steps[currentStep].pos,
                duration: duration,
              });

              wom.camera.animate('orientation', {
                to: steps[currentStep].ori,
                duration: duration,
              });

              womAsync.log(`Step ${currentStep} animating.`);
            }

            break;

          case 'N':
            if (duration != 1) {
              duration--;

              womAsync.log(`Duration is set to ${duration} sec.`);
            } else {
              womAsync.log(
                `Duration is already set to ${duration} sec and cannot be lowered.`,
              );
            }

            break;
          case 'M':
            duration++;
            womAsync.log(`Duration is set to ${duration} sec.`);
            break;

          default:
            break;
        }
      }
    },
    wom,
  );
}

export default {
  init: init,
};
