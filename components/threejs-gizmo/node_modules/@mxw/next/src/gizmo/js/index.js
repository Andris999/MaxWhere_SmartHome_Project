import * as THREE from '@mxw/three';
//import { TransformControls } from './TransformControls';
let camera, scene, renderer;
let geometry, material, mesh;
let control;
let snap = {
  state: false,
  isKeyActive: true,
  keyCode: 83,
  translateValue: 100,
  rotateValue: 15,
};

let webContentIDsToCommunicate = [];

let state = false;
let activeAreaDebug = false;

let showState;

//TODO view init

ipcRenderer.once('view-transfer', function (event, view) {
  camera.fov = view.FOV;
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.near = view.near;
  camera.far = view.far;
  camera.updateProjectionMatrix();
});
init();

function init() {
  showStateHandler();
  snapStateHandler();
  siblingBrowserWindowHandler();
  setupScene();
  targetHandling();
  targetSnyc();
  targetBackwardsHandling();
  setModeHandler();

  addKeyEvents();
  cameraSync();
  activeAreaStateHandler();
  resizeSync();
}

function resizeSync() {
  ipcRenderer.on('window-resolution-change', (event, resolution) => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });
}

function activeAreaStateHandler() {
  ipcRenderer.on('set-active-area-sebug-state', (event, state) => {
    activeAreaDebug = state;
  });
}

function drawActiveAreas(activeAreas) {
  var c = document.getElementById('activeAreaDisplay');

  var ctx = c.getContext('2d');

  ctx.clearRect(0, 0, c.width, c.height);
  c.width = window.innerWidth;
  c.height = window.innerHeight;
  drawNormalizedRectangle({ x: 0, y: 0, w: 1, h: 1 }, 'red', '6');
  activeAreas.forEach((activeArea) => {
    drawNormalizedRectangle(activeArea, 'yellow', '1');
  });

  function drawNormalizedRectangle({ x, y, w, h }, color, lineWidth) {
    ctx.beginPath();
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = color;
    ctx.rect(
      x * window.innerWidth,
      y * window.innerHeight,
      w * window.innerWidth,
      h * window.innerHeight,
    );
    ctx.stroke();
  }
}

function setupScene(view) {
  camera = new THREE.PerspectiveCamera(
    45,
    window.innerWidth / window.innerHeight,
    0.01,
    50000,
  );

  scene = new THREE.Scene();

  renderer = new THREE.WebGLRenderer({ alpha: true }); //{ alpha: true }
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setAnimationLoop(animation);
  document.body.appendChild(renderer.domElement);
  control = new TransformControls(camera, renderer.domElement);
  scene.add(control);
  control.setSize(0.7);
}

function targetSnyc() {
  control.addEventListener('objectChange', function (event) {
    if (mesh) {
      switch (control.mode) {
        case 'translate':
          ipcRenderer.send('target-translate', control.object.position);
          posChangeHandler();

          break;
        case 'rotate':
          // changed behavior on MaxWhere 5.0 due to electron
          let quaternion = {
            x: control.object.quaternion._x,
            y: control.object.quaternion._y,
            z: control.object.quaternion._z,
            w: control.object.quaternion._w,
          };
          ipcRenderer.send('target-rotate', quaternion);

          break;

        case 'scale':
          ipcRenderer.send('target-scale', control.object.scale);
          break;

        default:
          break;
      }
    }
  });

  //if gizmo is active send it to the main process
  control.addEventListener('mouseDown', function (event) {
    state = true;
    ipcRenderer.send('gizmo-state', state);
    webContentIDsToCommunicate.forEach((webcontentID) => {
      ipcRenderer.sendTo(webcontentID, 'gizmo-state', state);
    });

    activeAreaUpdate();
  });

  //if gizmo is not active send it to the main process
  control.addEventListener('mouseUp', function (event) {
    state = false;
    ipcRenderer.send('gizmo-state', state);
    webContentIDsToCommunicate.forEach((webcontentID) => {
      ipcRenderer.sendTo(webcontentID, 'gizmo-state', state);
    });

    activeAreaUpdate();
  });
}

function posChangeHandler() {
  activeAreaUpdate();

  webContentIDsToCommunicate.forEach((webcontentID) => {
    ipcRenderer.sendTo(webcontentID, 'gizmo-target-pos-2D', result);
  });
}

function activeAreaUpdate() {
  if (mesh) {
    // let activeArea = [getActiveArea()];
    let activeArea = getActiveArea();

    //console.log(activeArea)

    ipcRenderer.send('set-gizmo-active-areas', activeArea);
    if (activeAreaDebug) {
      drawActiveAreas(activeArea);
    }
  }
}

// function getActiveArea() {
//   let areaSizeFactor;
//   if (state) {
//     areaSizeFactor = 1 / 1.5;
//   } else {
//     areaSizeFactor = 1 / 6;
//   }

//   let pos2D = getMeshPosOn2D();
//   let areaSize = areaSizeFactor * control.size;
//   let areaSizeX = (window.innerHeight / window.innerWidth) * areaSize;
//   let areaSizeY = 1 * areaSize;
//   let activeArea = {
//     x: pos2D.x - areaSizeX,
//     y: pos2D.y - areaSizeY,
//     w: areaSizeX * 2,
//     h: areaSizeY * 2,
//   };
//   return activeArea;
// }

function computeScreenSpaceBoundingBox(mesh, camera) {
  // var vertices = mesh.geometry.vertices;
  var vertex = new THREE.Vector3();
  var min = new THREE.Vector3(1, 1, 1);
  var max = new THREE.Vector3(-1, -1, -1);

  for (var i = 0; i < mesh.geometry.attributes.position.count; i++) {
    var vertexWorldCoord = vertex
      .copy(
        new THREE.Vector3().fromBufferAttribute(
          mesh.geometry.attributes.position,
          i,
        ),
      )
      .applyMatrix4(mesh.matrixWorld);
    var vertexScreenSpace = vertexWorldCoord.project(camera);
    min.min(vertexScreenSpace);
    max.max(vertexScreenSpace);
  }

  return {
    x: (min.x + 1) / 2,
    y: 1 - (max.y + 1) / 2,
    w: (max.x + 1) / 2 - (min.x + 1) / 2,
    h: (max.y + 1) / 2 - (min.y + 1) / 2,
  };
}

function getActiveArea() {
  if (state) {
    return [{ x: 0, y: 0, w: 1, h: 1 }];
  } else {
    return control._gizmo.gizmo[control.mode].children.map((child) =>
      computeScreenSpaceBoundingBox(child, camera),
    );
  }
}

function getMeshPosOn2D() {
  let pos = mesh.position.clone();
  return convert3DposTo2D(pos);
}

function convert3DposTo2D(pos) {
  camera.updateMatrixWorld();
  let vector = pos.project(camera);

  return { x: (vector.x + 1) / 2, y: -(vector.y - 1) / 2 };
}

function setModeHandler() {
  ipcRenderer.on('set-gimzo-mode', (event, mode) => {
    setMode(mode);
  });
}

function siblingBrowserWindowHandler() {
  ipcRenderer.on('sibling-transfer', function (event, siblingID) {
    if (siblingID) {
      console.log('sibling added ' + siblingID);
      webContentIDsToCommunicate.push(siblingID);
    } else {
      console.log('Invalid sibling');
    }
  });
}

function showStateHandler() {
  ipcRenderer.on('show-state', function (event, show_state) {
    showState = show_state;

    control.showX = showState.translate.x;
    control.showY = showState.translate.y;
    control.showZ = showState.translate.z;
  });
}

function snapStateHandler() {
  ipcRenderer.on('set-snap', (event, snapState) => {
    if (snapState.hasOwnProperty('isKeyActive')) {
      snap.isKeyActive = snapState.isKeyActive;
    }

    if (snapState.hasOwnProperty('translateValue')) {
      snap.translateValue = snapState.translateValue;
    }

    if (snapState.hasOwnProperty('rotateValue')) {
      snap.rotateValue = snapState.rotateValue;
    }
  });
}
function targetHandling() {
  ipcRenderer.on('target-transfer', function (event, target) {
    if (target) {
      control.detach();
      scene.remove(mesh);
      mesh = undefined;
      geometry = new THREE.BoxGeometry(1, 1, 1);
      material = new THREE.MeshBasicMaterial();
      mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(
        target.position.x,
        target.position.y,
        target.position.z,
      );
      mesh.quaternion.set(
        target.quaternion.x,
        target.quaternion.y,
        target.quaternion.z,
        target.quaternion.w,
      );
      mesh.scale.set(target.scale.x, target.scale.y, target.scale.z);
      scene.add(mesh);
      control.attach(mesh);
      mesh.visible = false;
    } else {
      control.detach();
      scene.remove(mesh);
      mesh = undefined;
    }
    activeAreaUpdate();
  });
}

function targetBackwardsHandling() {
  ipcRenderer.on('target-translate-backwards', function (event, pos) {
    if (!state && mesh) {
      mesh.position.set(pos.x, pos.y, pos.z);
      posChangeHandler();
      activeAreaUpdate();
    }
  });

  ipcRenderer.on('target-rotate-backwards', function (event, quaternion) {
    if (!state && mesh) {
      mesh.quaternion.set(
        quaternion.x,
        quaternion.y,
        quaternion.z,
        quaternion.w,
      );
    }
    activeAreaUpdate();
  });

  ipcRenderer.on('target-scale-backwards', function (event, scale) {
    if (!state && mesh) {
      mesh.scale.set(scale.x, scale.y, scale.z);
      activeAreaUpdate();
    }

  });
}

function addKeyEvents() {
  window.addEventListener('keydown', function (event) {
    switch (event.keyCode) {
      case 81: // Q
        control.setSpace(control.space === 'local' ? 'world' : 'local');
        break;

      case 83: // S
        if (snap.isKeyActive) {
          if (!snap.state) {
            control.setTranslationSnap(snap.translateValue);
            control.setRotationSnap(THREE.Math.degToRad(snap.rotateValue));
          } else {
            control.setTranslationSnap(false);
            control.setRotationSnap(false);
          }
          snap.state = !snap.state;
        }

        break;

      case 87: // W
        if (
          showState.translate.x == false &&
          showState.translate.y == false &&
          showState.translate.z == false
        ) {
          return;
        }
        setMode('translate');

        break;

      case 69: // E
        if (
          showState.rotate.x == false &&
          showState.rotate.y == false &&
          showState.rotate.z == false
        ) {
          return;
        }
        setMode('rotate');

        break;

      case 82: // R
        if (
          showState.scale.x == false &&
          showState.scale.y == false &&
          showState.scale.z == false
        ) {
          return;
        }
        setMode('scale');

        break;

      case 187:
      case 107: // +, =, num+
        control.setSize(control.size + 0.1);
        break;

      case 189:
      case 109: // -, _, num-
        control.setSize(Math.max(control.size - 0.1, 0.1));
        break;
    }
  });
}

function cameraSync() {
  ipcRenderer.on('camera-orientaion', function (event, orientation) {
    camera.quaternion.set(
      orientation.x,
      orientation.y,
      orientation.z,
      orientation.w,
    );
    activeAreaUpdate();
  });
  ipcRenderer.on('camera-position', function (event, position) {
    camera.position.set(position.x, position.y, position.z);
    activeAreaUpdate();
  });
}

function animation() {
  renderer.render(scene, camera);
}

function setMode(mode) {
  switch (mode) {
    case 'translate':
      control.setMode('translate');

      // axis settings
      control.showX = showState.translate.x;
      control.showY = showState.translate.y;
      control.showZ = showState.translate.z;

      break;

    case 'rotate':
      control.setMode('rotate');
      // axis settings
      control.showX = showState.rotate.x;
      control.showY = showState.rotate.y;
      control.showZ = showState.rotate.z;

      break;

    case 'scale':
      control.setMode('scale');

      control.showX = showState.scale.x;
      control.showY = showState.scale.y;
      control.showZ = showState.scale.z;

      break;

    default:
      break;
  }
  activeAreaUpdate();
}
