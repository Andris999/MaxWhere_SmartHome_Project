/* Copyright (C) 2015-2019 MISTEMS Ltd. - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 */

import {
  wom,
  context,
  modules,
  Mesh,
  Node,
  Overlay,
  Vector3,
  Quaternion,
  NodeMouseEventObject,
  WomKeyboardEventObject,
  WomCommonEventObject,
} from 'maxwhere';
import womAsync from '../wrappers/womAsync.module';
import * as utils from '../utils/index';

import { ipcMain } from 'electron';
import path from 'path';

export default class Gizmo {
  options: GizmoOptions;
  spatialGizmo: boolean = false;
  isGizmoActive: boolean = false;
  overlay: Overlay;
  target?: Node;
  constructor(options: GizmoOptions) {
    this.options = options;

    this.overlay = this.addOverlay(options);

    this.cameraSync();
    this.targetSync();
    this.resizeSync();

    ipcMain.on('gizmo-state', this.setStateChange);

    if (this.options.mode == 'editor') {
      ipcMain.on('gizmo_target_rq', (event, id) => {
        this.attachTarget(id);
      });
    } else {
      wom.on('click', this.attachTargetListener);
    }
  }

  targetTranslate = (event: Electron.IpcMainEvent, pos: Vector3) => {
    this.target?.setPosition(pos.x, pos.y, pos.z, 'absolute', 'world');
  };
  targetRotate = (event: Electron.IpcMainEvent, ori: Quaternion) => {
    this.target?.setOrientation(
      ori.w,
      ori.x,
      ori.y,
      ori.z,
      'absolute',
      'world',
    );
  };
  targetScale = (event: Electron.IpcMainEvent, scale: Vector3) => {
    this.target?.setScale(scale.x, scale.y, scale.z);
  };

  addOverlay = (options: GizmoOptions) => {
    let overlay = wom.create('overlay', {
      id: 'gizmo-overlay',
      width: wom.appConfig.width, // 1920 - 640
      height: wom.appConfig.height, // 1080 - 360
      'resolution-width': wom.appConfig.width,
      'resolution-height': wom.appConfig.height,
      scaleFactor: 1, // do not allow DPI scaling
      // accept mouse events to make it orbit-able
      physical: { raycast: true },
      // URL to load
      url: path.join(__dirname, '../../', 'controller-window', 'index.html'),
      // accept input events when hovered
      inputDisabled: false,
      nodeIntegration: true,
      transparent: true,
      directKeyEvent: false,
      zorder: 40,
      done: (o) => {
        //o.hide();
        this.setActiveAreaToZero();
        if (this.options.mode == 'editor') {
          // ipcMain.on('gizmo_toggle_rq', (event, value) => {
          //   if (value) {
          //     this.showOverlay();
          //   } else {
          //     this.hideOverlay();
          //   }
          // });
        } else {
          //wom.on('contextMenu', this.showOverlayListener);
          wom.on('click', this.detachTargetListener);
        }

        //o.browserWindow.webContents.openDevTools({ mode: 'detach' });
      },
    });

    overlay.once('ready', () => {
      if (options.siblingContentID) {
        this.sendWebcontentID(options.siblingContentID);
      }

      ipcMain.on('set-gizmo-active-areas', (event, activeArea) => {
        overlay.setActiveAreas(activeArea);
      });

      overlay.browserWindow.webContents.send(
        'set-active-area-sebug-state',
        this.options.activeAreaDebug,
      );

      if (this.options.snap) {
        overlay.browserWindow.webContents.send('set-snap', this.options.snap);
      }

      if (this.options.show) {
        overlay.browserWindow.webContents.send('show-state', this.options.show);
      } else {
        overlay.browserWindow.webContents.send('show-state', {
          translate: { x: true, y: true, z: true },
          rotate: { x: true, y: true, z: true },
          scale: { x: true, y: true, z: true },
        });
      }

      // send view props for camera init
      this.overlay.browserWindow.webContents.send(
        'view-transfer',
        //@ts-ignore
        this.getViewProps(wom.view),
      );
    });

    wom.render(overlay);
    return overlay;
  };

  setActiveAreaToZero = async () => {
    await utils.sleep(2000);
    this.overlay.setActiveAreas([{ x: 0, y: 0, w: 0.001, h: 0.001 }]);
  };

  setStateChange = (event: Electron.IpcMainEvent, state: boolean) => {
    if (state && wom.isSpatialControlEnabled()) {
      wom.setSpatialControl(false);
      this.spatialGizmo = true;
    } else if (this.spatialGizmo) {
      wom.setSpatialControl(true);
      this.spatialGizmo = false;
    }
    this.isGizmoActive = state;
  };

  sendWebcontentID = (webContentID: string) => {
    this.overlay.browserWindow.webContents.send(
      'sibling-transfer',
      webContentID,
    );
  };

  targetTranslateBackwardsHandler = () => {
    if (!this.isGizmoActive) {
      this.overlay.browserWindow.webContents.send(
        'target-translate-backwards',
        this.target?.getPosition(),
      );
    }
  };

  targetRotateBackwardsHandler = () => {
    if (!this.isGizmoActive) {
      this.overlay.browserWindow.webContents.send(
        'target-rotate-backwards',
        this.target?.getOrientation(),
      );
    }
  };

  targetScaleBackwardsHandler = () => {
    if (!this.isGizmoActive) {
      this.overlay.browserWindow.webContents.send(
        'target-scale-backwards',
        this.target?.getScale(),
      );
    }
  };

  attachTarget = (id: string) => {
    this.detachTarget();
    if (id) {
      let node = wom.select(`#${id}`) as Mesh;
      console.log(`attach gizmo target id: ${id}, url: ${node.url}`);
      this.target = node;

      this.overlay.browserWindow.webContents.send(
        'target-transfer',
        this.getNodeProps(this.target),
      );

      womAsync.selfAwareListener(
        { type: 'node-position', subject: this.target.node.GetName() },
        this.targetTranslateBackwardsHandler,
        this.target,
      );
      womAsync.selfAwareListener(
        { type: 'node-orientation', subject: this.target.node.GetName() },
        this.targetRotateBackwardsHandler,
        this.target,
      );
      womAsync.selfAwareListener(
        { type: 'node-scale', subject: this.target.node.GetName() },
        this.targetScaleBackwardsHandler,
        this.target,
      );

      womAsync.selfAwareListener(
        { type: 'node-delete', subject: this.target.node.GetName() },
        () => {
          this.detachTarget();
        },
        this.target,
      );
    } else {
      this.target = undefined;
    }
  };

  detachTarget() {
    if (this.target && this.target.node) {
      this.overlay.browserWindow.webContents.send('target-transfer', '');
      wom.removeListener(
        { type: 'node-position', subject: this.target.node.GetName() },
        this.targetTranslateBackwardsHandler,
      );
      wom.removeListener(
        { type: 'node-orientation', subject: this.target.node.GetName() },
        this.targetRotateBackwardsHandler,
      );
      wom.removeListener(
        { type: 'node-scale', subject: this.target.node.GetName() },
        this.targetScaleBackwardsHandler,
      );
      this.target = undefined;
    } else if (this.target) {
      this.overlay.browserWindow.webContents.send('target-transfer', '');

      this.target = undefined;
    }
  }

  attachTargetListener = (event: NodeMouseEventObject) => {
    if (event.ctrlKey) {
      if (event.target.includes('_physical') && event.is3d) {
        let id = event.target.replace('_physical', '');
        console.log(`attach target to gizmo: ${id}`);
        this.attachTarget(id);
      }
    }
  };

  detachTargetListener = (event: NodeMouseEventObject) => {
    if (this.target && !event.target) {
      this.detachTarget();
      this.setActiveAreaToZero();
    }
  };

  sendCameraOrientation = () => {
    this.overlay.browserWindow.webContents.send(
      'camera-orientaion',
      wom.camera.getOrientation(),
    );
  };
  sendCameraPosition = () => {
    this.overlay.browserWindow.webContents.send(
      'camera-position',
      wom.camera.getPosition(),
    );
  };
  cameraSync = () => {
    // sync the camera orientation
    wom.on({ type: 'node-orientation', subject: 'CogiNavOrbitHelper' }, () => {
      this.sendCameraOrientation();
      this.sendCameraPosition();
    });

    womAsync.selfAwareListener(
      { type: 'node-position', subject: 'CogiNavOrbitHelper' },
      () => {
        this.sendCameraOrientation();
        this.sendCameraPosition();
      },
      this.overlay,
    );

    wom.on(
      { type: 'node-orientation', subject: wom.camera.node.GetName() },
      this.sendCameraOrientation,
    );

    //sync the camera position
    wom.on(
      { type: 'node-position', subject: wom.camera.node.GetName() },
      this.sendCameraPosition,
    );
  };

  clear() {
    wom.removeListener('click', this.detachTargetListener);
    wom.removeListener('dblclick', this.attachTargetListener);

    wom.removeListener(
      { type: 'node-orientation', subject: wom.camera.node.GetName() },
      this.sendCameraOrientation,
    );
    wom.removeListener(
      { type: 'node-position', subject: wom.camera.node.GetName() },
      this.sendCameraPosition,
    );
    wom.removeListener('contextMenu', this.attachTargetListener);
    //wom.removeListener('resize', this.resizeWindow);
    ipcMain.removeListener('target-translate', this.targetTranslate);

    ipcMain.removeListener('target-rotate', this.targetRotate);

    ipcMain.removeListener('target-scale', this.targetScale);
    this.overlay.clear();
  }

  /**
   * Notify renderer process in case resized MaxWhere window
   */
  resizeSync() {
    // wom.on('resize', this.resizeWindow);
    wom.on('resize', ({ w, h }) => {
      this.overlay.setResolution(w, h);
      this.overlay.setSize(w, h);
      this.overlay.browserWindow.webContents.send('window-resolution-change', {
        w,
        h,
      });
    });
    wom.on('dpi-change', ({ dpi }) => {
      this.overlay.setPixelScaleFactor(dpi);
    });
  }

  /**
   * Register event listereners in case the  target in renderer process changes
   */
  targetSync() {
    ipcMain.on('target-translate', this.targetTranslate);

    ipcMain.on('target-rotate', this.targetRotate);

    ipcMain.on('target-scale', this.targetScale);
  }

  getViewProps(view: any) {
    let viewProps = {
      FOV: view.GetFoV(),
      far: view.GetClipDistances().far,
      near: view.GetClipDistances().near,
    };
    return viewProps;
  }

  /**
   * Get node props
   * @param {Node} node
   * @returns Node props
   */
  getNodeProps(node: Node) {
    let position = node.getPosition();
    let orientation = node.getOrientation();
    let scale = node.getScale();

    let nodeProps = {
      position: {
        x: position.x,
        y: position.y,
        z: position.z,
      },
      quaternion: {
        x: orientation.x,
        y: orientation.y,
        z: orientation.z,
        w: orientation.w,
      },
      scale: {
        x: scale.x,
        y: scale.y,
        z: scale.z,
      },
    };
    return nodeProps;
  }

  fovSync() {}
}

interface GizmoOptions {
  activeAreaDebug?: boolean;
  show?: {
    translate: { x: boolean; y: boolean; z: boolean };
    rotate: { x: boolean; y: boolean; z: boolean };
    scale: { x: boolean; y: boolean; z: boolean };
  };
  snap?: {
    isKeyActive?: boolean;
    translateValue?: number;
    rotateValue?: number;
  };

  mode?: 'editor';
  siblingContentID?: string;
}
