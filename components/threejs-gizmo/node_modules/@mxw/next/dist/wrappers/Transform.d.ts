import * as THREE from '@mxw/three';
import { AngleAxis, Bezier, EasingFunction, Node, Quaternion, Reference, Space, Vector3 } from 'maxwhere';
export default class Transform {
    node: Node;
    forwardIdentity: THREE.Vector3;
    upIdentity: THREE.Vector3;
    rightIdentity: THREE.Vector3;
    constructor(node: Node, forwardIdentity?: THREE.Vector3, upIdentity?: THREE.Vector3, rightIdentity?: THREE.Vector3);
    /**
     * World position of object
     */
    get position(): THREE.Vector3;
    set position(value: THREE.Vector3);
    /**
     * Local position of object
     */
    get localPosition(): THREE.Vector3;
    set localPosition(value: THREE.Vector3);
    /**
     * World rotation in quaternion.
     */
    get rotation(): THREE.Quaternion;
    set rotation(value: THREE.Quaternion);
    /**
     * Local rotation in quaternion
     */
    get localRotation(): THREE.Quaternion;
    set localRotation(value: THREE.Quaternion);
    /**
     * World scale
     */
    get scale(): THREE.Vector3;
    set scale(value: THREE.Vector3);
    /**
     * Local scale
     */
    get localScale(): THREE.Vector3;
    set localScale(value: THREE.Vector3);
    /**
     * World matrix
     */
    get matrix(): THREE.Matrix4;
    /**
     * Local matrix
     */
    get localMatrix(): THREE.Matrix4;
    /**
     * Returns a normalized vector representing the blue axis of the transform in world space.
     */
    get forward(): THREE.Vector3;
    set forward(value: THREE.Vector3);
    /**
     * The green axis of the transform in world space.
     */
    get up(): THREE.Vector3;
    set up(value: THREE.Vector3);
    /**
     * The red axis of the transform in world space.
     */
    get right(): THREE.Vector3;
    set right(value: THREE.Vector3);
    /**
     * The rotation as Euler angles in radians.
     */
    get eulerAngles(): THREE.Euler;
    set eulerAngles(value: THREE.Euler);
    /**
     * The rotation as Euler angles in degrees.
     */
    get eulerAnglesInDegrees(): {
        x: number;
        y: number;
        z: number;
    };
    /**
     * The rotation as Euler angles in radians relative to the parent transform's rotation.
     */
    get localEulerAngles(): THREE.Euler;
    set localEulerAngles(value: THREE.Euler);
    /**
     * The rotation as Euler angles in degrees relative to the parent transform's rotation.
     */
    get localEulerAnglesInDegrees(): {
        x: number;
        y: number;
        z: number;
    };
    /**
     * Return children transforms
     * Warning! Forward, up and right vectors will be default and might give incorrect result.
     */
    get children(): Transform[];
    /**
     * Converts the vector from this object's local space to world space.
     *
     * @param pos A vector representing a position in this object's local space.
     * @returns The new converted vector
     */
    localToWorld(pos: THREE.Vector3): THREE.Vector3;
    /**
     * Converts the vector from world space to this object's local space.
     *
     * @param pos A vector representing a position in world space.
     * @returns The new converted vector
     */
    worldToLocal(pos: THREE.Vector3): THREE.Vector3;
    /**
     * Converts the vector from this object's local space to another local space.
     *
     * @param pos A vector representing a position in this object's local space.
     * @param transform The other object which local space we want to use.
     * @returns The new converted vector
     */
    localToLocal(pos: THREE.Vector3, transform: Transform): THREE.Vector3;
    /**
     * Rotates the transform so the forward vector points at /target/'s current positions's X and Z cooridinates.
     * @param pos position too look at
     */
    lookAtXZ(pos: THREE.Vector3): void;
    /**
     * Rotates the transform so the forward vector points at /target/'s current position.
     * @param pos position too look at
     */
    lookAt(pos: THREE.Vector3): void;
    /**
     * Look at position and animate it.
     * @param pos position to look at
     * @param duration duration in sec
     * @param overrideCurrentPos overrides this.position during calculation
     */
    lookAtAnimate(pos: THREE.Vector3, duration: number, overrideCurrentPos?: THREE.Vector3): Promise<void>;
    /**
     * Look at direction.
     * @param dir Direction vector.
     */
    lookAtDir(dir: THREE.Vector3): void;
    /**
     * Promise wrapper for Maxwhere Node.animate
     * Animates the Node by changing the specified attribute of its transformation. Animation will change the attribute according to the specified option parameters step by step.
     *
     * @param attribute Transformation type. Possible values are position, scale, orientation. Matching values are Object {x, y, z} for position, scale and Object {w, x, y, z} or {angle, axis} for orientation
     * @param options Options determining the run of the animation.
     * @param complete Callback for completed animation. If repeat is true the animation will be completed only if stopped manually.
     * @returns Promise which resolves when animation is completed
     */
    animate(attribute: 'orientation' | 'position' | 'scale', options: {
        /**
         * Start values of the animated attribute for every step. If it's omitted it will animate from the actual value of the attribute. Otherwise the length of array should be equal to number of animation steps.
         */
        from?: Quaternion | AngleAxis | Array<Quaternion | AngleAxis> | Vector3 | Array<Vector3>;
        /**
         * End values of the animated attribute for every step. The length of array should be equal to number of animation steps.
         */
        to: Quaternion | AngleAxis | Array<Quaternion | AngleAxis> | Vector3 | Array<Vector3>;
        /**
         * Duration of every animation steps in seconds. If animating through multiple steps but only one duration is provided, it will be used for every step. Otherwise the length of array should be equal to number of animation steps.
         */
        duration: number | Array<number>;
        /**
         *  Repeat the animation for ever. Default is false.
         */
        repeat?: boolean;
        /**
         * Loop the animation for ever. Animation will be played, then played backwards and repeated (overrides repeat if given contradictory). Default is false.
         */
        loop?: boolean;
        /**
         * The cubic easing function of the animation which defines the curve of temporal run.
         */
        cubic?: Bezier | EasingFunction;
        /**
         * Reference of the attribute adjustment.
         */
        reference?: Reference;
        /**
         *  Space the attribute adjustment is applied in.
         */
        space?: Space;
    }, complete?: Function): Promise<unknown>;
    /**
     * Look at this with maxwhere camera.
     * @param duration animation duration in sec
     * @param offset position offset for camera compared to this.position. If offset is an array the closest position to the current camera position will be chosen.
     */
    lookAtThisWithCamera(duration: number, offset: THREE.Vector3 | THREE.Vector3[]): Promise<void>;
    /**
     * Rotate an object along an axis in object space. The axis is assumed to be normalized.
     * @param axis A normalized vector in object space.
     * @param angle The angle in degrees.
     * @returns
     */
    rotateOnAxis(axis: THREE.Vector3, angle: number): this;
    /**
     *  Rotate an object along an axis in world space. The axis is assumed to be normalized.
     * @param axis A normalized vector in object space.
     * @param angle The angle in degrees.
     * @returns
     */
    rotateOnWorldAxis(axis: THREE.Vector3, angle: number): this;
}
