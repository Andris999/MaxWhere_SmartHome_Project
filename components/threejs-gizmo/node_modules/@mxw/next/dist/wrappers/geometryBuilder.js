"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const THREE = __importStar(require("@mxw/three"));
const lodash_1 = __importDefault(require("lodash"));
const three_utils_1 = __importDefault(require("@mxw/three-utils"));
const TextGeometry_1 = require("../utils/TextGeometry");
const FontLoader_1 = require("../utils/FontLoader");
class GeometryBuilder {
    /**
     * Get faces of a geometry converted from a three.js BufferGeometry to a maxwhere manualvisual "section".
     *
     *  NOTE: color is only  affected if you use a special "vertex driven" material. For exmaple the built in "Physics/DebugDraw/VertexDriven" material.
     * @param geometry
     * @param material_name name of the material
     * @param color Normalized rgba color, number values are betwenn 0 and 1. Example: {r:1, g:0.5, b:0, a:1}. If "random" is set than every vertex gets a random color.
     * @returns Section
     */
    static getFacesFromGeometry(geometry, material_name, color) {
        //geometry.toNonIndexed();
        const positionAttribute = geometry.toNonIndexed().attributes.position;
        const vertex = new THREE.Vector3();
        let mwGeometry = [];
        if (color && color != 'random') {
            mwGeometry.push({
                type: 'color',
                arg: color,
            });
        }
        for (let vertexIndex = 0; vertexIndex < positionAttribute.count; vertexIndex += 3) {
            if (color == 'random') {
                mwGeometry.push({
                    type: 'color',
                    arg: {
                        r: Math.random(),
                        g: Math.random(),
                        b: Math.random(),
                        a: Math.random(),
                    },
                });
            }
            vertex.fromBufferAttribute(positionAttribute, vertexIndex);
            mwGeometry.push({
                type: 'position',
                arg: { x: vertex.x, y: vertex.y, z: vertex.z },
            });
            vertex.fromBufferAttribute(positionAttribute, vertexIndex + 1);
            mwGeometry.push({
                type: 'position',
                arg: { x: vertex.x, y: vertex.y, z: vertex.z },
            });
            vertex.fromBufferAttribute(positionAttribute, vertexIndex + 2);
            mwGeometry.push({
                type: 'position',
                arg: { x: vertex.x, y: vertex.y, z: vertex.z },
            });
        }
        let section = {
            material_name: material_name,
            renderop: 'trianglelist',
            geometry: mwGeometry,
        };
        return section;
    }
    /**
     * Get wireframe of a geometry converted from a three.js BufferGeometry to a maxwhere manualvisual "section".
     *
     *  NOTE: color is only  affected if you use a special "vertex driven" material. For exmaple the built in "Physics/DebugDraw/VertexDriven" material.
     * @param geometry
     * @param material_name name of the material
     * @param color Normalized rgba color, number values are betwenn 0 and 1. Example: {r:1, g:0.5, b:0, a:1}. If "random" is set than every vertex gets a random color.
     * @returns Section
     */
    static getWireframeFromGeometry(geometry, material_name, color) {
        const wireframeGeometry = new THREE.WireframeGeometry(geometry);
        const positionAttribute = wireframeGeometry.attributes.position;
        const vertex = new THREE.Vector3();
        let mwGeometry = [];
        if (color && color != 'random') {
            mwGeometry.push({
                type: 'color',
                arg: color,
            });
        }
        for (let vertexIndex = 0; vertexIndex < positionAttribute.count; vertexIndex += 2) {
            if (color == 'random') {
                mwGeometry.push({
                    type: 'color',
                    arg: {
                        r: Math.random(),
                        g: Math.random(),
                        b: Math.random(),
                        a: Math.random(),
                    },
                });
            }
            vertex.fromBufferAttribute(positionAttribute, vertexIndex);
            mwGeometry.push({
                type: 'position',
                arg: { x: vertex.x, y: vertex.y, z: vertex.z },
            });
            vertex.fromBufferAttribute(positionAttribute, vertexIndex + 1);
            mwGeometry.push({
                type: 'position',
                arg: { x: vertex.x, y: vertex.y, z: vertex.z },
            });
        }
        let section = {
            material_name: material_name,
            renderop: 'linelist',
            geometry: mwGeometry,
        };
        return section;
    }
    /**
     * Get edges of a geometry converted from a three.js BufferGeometry to a maxwhere manualvisual "section".
     *
     *  NOTE: color is only  affected if you use a special "vertex driven" material. For exmaple the built in "Physics/DebugDraw/VertexDriven" material.
     * @param geometry
     * @param material_name name of the material
     * @param color Normalized rgba color, number values are betwenn 0 and 1. Example: {r:1, g:0.5, b:0, a:1}. If "random" is set than every vertex gets a random color.
     * @returns Section
     */
    static getEdgesFromGeometry(geometry, material_name, color) {
        const wireframeGeometry = new THREE.EdgesGeometry(geometry, 5);
        const positionAttribute = wireframeGeometry.attributes.position;
        const vertex = new THREE.Vector3();
        let mwGeometry = [];
        if (color && color != 'random') {
            mwGeometry.push({
                type: 'color',
                arg: color,
            });
        }
        for (let vertexIndex = 0; vertexIndex < positionAttribute.count; vertexIndex += 2) {
            if (color == 'random') {
                mwGeometry.push({
                    type: 'color',
                    arg: {
                        r: Math.random(),
                        g: Math.random(),
                        b: Math.random(),
                        a: Math.random(),
                    },
                });
            }
            vertex.fromBufferAttribute(positionAttribute, vertexIndex);
            mwGeometry.push({
                type: 'position',
                arg: { x: vertex.x, y: vertex.y, z: vertex.z },
            });
            vertex.fromBufferAttribute(positionAttribute, vertexIndex + 1);
            mwGeometry.push({
                type: 'position',
                arg: { x: vertex.x, y: vertex.y, z: vertex.z },
            });
        }
        let section = {
            material_name: material_name,
            renderop: 'linelist',
            geometry: mwGeometry,
        };
        return section;
    }
    static getLineSectionFromPoints(points, material_name, color) {
        let section = {
            material_name: material_name,
            renderop: 'linestrip',
            geometry: [],
        };
        if (color) {
            if (lodash_1.default.isArray(color)) {
                let posGeometries = this.convertThreePointsToPosGeometryArray(points);
                posGeometries.forEach((posgeometry, index) => {
                    section.geometry.push({
                        type: 'color',
                        arg: {
                            r: ((color[1].r - color[0].r) / points.length) * index +
                                color[0].r,
                            g: ((color[1].g - color[0].g) / points.length) * index +
                                color[0].g,
                            b: ((color[1].b - color[0].b) / points.length) * index +
                                color[0].b,
                            a: ((color[1].a - color[0].a) / points.length) * index +
                                color[0].a,
                        },
                    }, posgeometry);
                });
            }
            else if (color == 'random') {
                let posGeometries = this.convertThreePointsToPosGeometryArray(points);
                posGeometries.forEach((posgeometry) => {
                    section.geometry.push({
                        type: 'color',
                        arg: {
                            r: Math.random(),
                            g: Math.random(),
                            b: Math.random(),
                            a: 1,
                        },
                    }, posgeometry);
                });
            }
            else {
                section.geometry.push({
                    type: 'color',
                    arg: color,
                });
                section.geometry.push(...this.convertThreePointsToPosGeometryArray(points));
            }
        }
        else {
            section.geometry.push(...this.convertThreePointsToPosGeometryArray(points));
        }
        return section;
    }
    static convertThreePointsToPosGeometryArray(points) {
        return points.map((point) => {
            return {
                type: 'position',
                arg: three_utils_1.default.V3ToMw(point),
            };
        });
    }
    /**
     * Get bounding shape from a three.js geometry
     * @param geometry
     * @param type
     * @returns
     */
    static getPhysicalShapeFromGeometry(geometry, type) {
        if (type == 'boundingbox') {
            geometry.computeBoundingBox();
            let bbox = geometry.boundingBox;
            let center = three_utils_1.default.V3ToMw(bbox.getCenter(new THREE.Vector3()));
            let size = bbox.getSize(new THREE.Vector3());
            return {
                offset: center,
                width: size.x,
                height: size.y,
                depth: size.z,
                shape: 'box',
            };
        }
        else if (type == 'boundingsphere') {
            geometry.computeBoundingSphere();
            let bsphere = geometry.boundingSphere;
            let center = three_utils_1.default.V3ToMw(bsphere.center);
            let radius = bsphere.radius;
            return {
                offset: center,
                radius: radius,
                shape: 'sphere',
            };
        }
        return {};
    }
    /**
     * Build a three.js TextGeometry
     * @param text
     * @param parameters
     * @returns
     */
    static getTextGeometry(text, parameters) {
        let textGeometry;
        if (parameters.fontJSON) {
            let font = { font: new FontLoader_1.Font(parameters.fontJSON) };
            textGeometry = new TextGeometry_1.TextGeometry(text, Object.assign(parameters, font));
        }
        else {
            textGeometry = new TextGeometry_1.TextGeometry(text, parameters);
        }
        return textGeometry;
    }
}
exports.default = GeometryBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VvbWV0cnlCdWlsZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3dyYXBwZXJzL2dlb21ldHJ5QnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBU0Esa0RBQW9DO0FBQ3BDLG9EQUF1QjtBQUN2QixtRUFBa0M7QUFDbEMsd0RBQXFEO0FBQ3JELG9EQUEyQztBQUUzQyxNQUFlLGVBQWU7SUFDNUI7Ozs7Ozs7O09BUUc7SUFDSCxNQUFNLENBQUMsb0JBQW9CLENBQ3pCLFFBQThCLEVBQzlCLGFBQXFCLEVBQ3JCLEtBQXdCO1FBRXhCLDBCQUEwQjtRQUMxQixNQUFNLGlCQUFpQixHQUFHLFFBQVEsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDO1FBRXRFLE1BQU0sTUFBTSxHQUFHLElBQUksS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRW5DLElBQUksVUFBVSxHQUF5QyxFQUFFLENBQUM7UUFFMUQsSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLFFBQVEsRUFBRTtZQUM5QixVQUFVLENBQUMsSUFBSSxDQUFDO2dCQUNkLElBQUksRUFBRSxPQUFPO2dCQUNiLEdBQUcsRUFBRSxLQUFLO2FBQ1gsQ0FBQyxDQUFDO1NBQ0o7UUFFRCxLQUNFLElBQUksV0FBVyxHQUFHLENBQUMsRUFDbkIsV0FBVyxHQUFHLGlCQUFpQixDQUFDLEtBQUssRUFDckMsV0FBVyxJQUFJLENBQUMsRUFDaEI7WUFDQSxJQUFJLEtBQUssSUFBSSxRQUFRLEVBQUU7Z0JBQ3JCLFVBQVUsQ0FBQyxJQUFJLENBQUM7b0JBQ2QsSUFBSSxFQUFFLE9BQU87b0JBQ2IsR0FBRyxFQUFFO3dCQUNILENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFO3dCQUNoQixDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRTt3QkFDaEIsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLEVB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